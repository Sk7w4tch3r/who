<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0043)http://www.tom-yam.or.jp/2238/work/32v.html -->
<HTML><HEAD><TITLE>32v Report</TITLE>
<META content="text/html; charset=windows-1252" http-equiv=Content-Type>
<META content="MSHTML 5.00.2919.6307" name=GENERATOR></HEAD>
<BODY aLink=#ff0044 bgColor=#ffffff link=#0000ff text=#000000 vLink=#330088>
<H1>A UNIX&#153; Operating System for the DEC VAX-11/780 Computer</H1>
<DL>
  <DD><I>Thomas B. London<BR></I></DD></DL>
<DL>
  <DD><I>John F. Reiser<BR></I></DD></DL>
<DL>
  <DT>
  <DT>
  <DD>NOTE:<I> This is a revived version of an internal Bell Labs memo by Reiser 
  and London, dated July 7, 1978. This rendition was generated by OCR from a 
  scanned copy of the original memo, with the result edited by Dennis Ritchie.
<p>
This improved version of the HTML fixes some typos
and adds markup that is missing even
in the PDF and PS renditions.  It was kindly supplied by Naoki Hamada. 
  I am responsible for remaining problems.<BR>--DMR </I>
  <DT>
  <DD></DD></DL><BR>
<DL>
  <DD>
  <H4>ABSTRACT</H4>A UNIX operating system together with a complete user 
  environment has been implemented on the VAX-11/780 computer manufactured by 
  Digital Equipment Corporation. The VAX-11/780 system provides 32-bit addresses 
  and data. It uses the same input/output devices as the PDP-11 family and is 
  controlled through a console computer which can be remotely accessed. 
  Additionally, the VAX-11/780 is priced nearly the same as a PDP-11/70 and 
  executes most programs somewhat faster than a PDP-11/70. 
  <P>This memorandum describes the VAX-11/780 hardware and the UNIX operating 
  system and the C programming language software implementation, records some 
  observations on program portability, and speculates ways in which the 
  operating system overhead can be significantly reduced. The authors conclude 
  that the VAX-11/780 provides and excellent hardware environment for running 
  UNIX and C software. </P></DD></DL>
<H4>1. Introduction </H4>
<P>The VAX-11/780 [1] is a new, general-purpose, stored-program electronic 
digital computer manufactured by Digital Equipment Corporation. At minicomputer 
prices it provides addresses and data which are 32 bits wide; the traditional 
minicomputer address space bound of 64K is gone. This memorandum describes the 
VAX-11/780 and the implementation of a UNIX operating system and complete user 
environment for it. Section 2 contains an overview suitable for general 
consumption; details normally of interest only to devotees of computer system 
architecture appear in Section 3. The authors comment on software portability in 
Section 4. </P>
<H4>2. Overview </H4>
<P><B>Environment.</B> A user of UNIX and C software on the PDP-11 will find 
that the VAX-11/780 provides a very similar environment. There are no apparent 
differences in the command language or the vast majority of programs which are 
customarily invoked directly from the shell. A casual user probably will not be 
able to distinguish the hardware, except by issuing the command "who am i" 
(which identifies the hardware and the current user) or by noting that one of 
the columns printed by the process status command <I>ps</I> is in hexadecimal 
rather than octal. The C language programmer will find that <B>int</B>, 
<B>long</B>, and pointer data types all occupy 4 bytes (a short still occupies 2 
bytes), and that a <B>long</B> has its two halves stored in a different order on 
the PDP-11 than on the VAX-11. Characters still suffer sign extension when 
converted to longer integer types, but one may use the declaration <B>unsigned 
char</B>. </P>
<P><B>Hardware.</B> The VAX-11 is a follow-on computer to the PDP-11. The 
architecture seen by the user-mode assembly-language programmer of a VAX-11 is 
"culturally compatible" with the PDP-11. Specific details differ, but a 
programmer familiar with the PDP-11 can quickly understand the differences. The 
VAX-11 provides UNIBUS and MASSBUS interfaces and uses the same input/output 
peripheral devices as a PDP-11. </P>
<P>Significant new features of the VAX-1l include an extended virtual address 
space, intelligent console, and dramatically improved physical packaging. The 
address space of a process is divided into a few gigantic segments. Each segment 
is further divided into a large number of small pages. Sufficient hardware 
exists to make demand paging a viable memory management strategy. All console 
functions are handled by an LSI-11 microcomputer through a standard ASCII 
terminal. The terminal may be remotely located from the processor and can still 
halt, boot, or diagnose the VAX-11. The mechanical and physical design of the 
VAX-11/780 is well done. The processor contains no sliding drawers or moving 
cables. All parts are easily accessible for servicing. Adequate airflow is 
maintained even under maintenance conditions. </P>
<P><B>Configuration.</B> The actual configuration purchased by Department 1353 
is: 
<DL>
  <DT>
  <DD><TT><PRE>VAX-11/780 cpu
0.5 megabytes memory with battery backup
floating-point accelerator
12Kbyte user-writeable control store
UNIBUS adaptor with DZ11 (8 RS-232C lines)
MASSBUS adaptor with TE16 tape drive (800/1600 bpi)
MASSBUS adaptor with two RP06 disk spindles (176M bytes per spindle)
additional BA11KE UNIBUS box
</PRE></TT></DD></DL>The list price of the above configuration in February 1978 
was $241,255; the price including a DEC discount to a Bell Labs purchaser was 
$200,242. 
<P></P>
<P><B>Software.</B> We have implemented a UNIX operating system [2] and complete 
user software environment on the VAX-11/780. The operating system is Research 
version 7 as of April 15, 1978. The environment includes the Bourne shell, C 
compiler, code improver <I>c2</I>, assembler, loader, debugger, standard I/O 
subroutine library <B>libS</B>, C subroutine library <B>libc</B>, source code 
control system SCCS, <I>nroff/troff</I> and more than 130 commands. Maintenance 
programs for file system checking, bootstrapping, and physical disk pack 
handling have also been implemented. </P>
<P>We began with the C language code of Research version 7 of the UNIX operating 
system, and a PDP-11/45 running UNIX as a bootstrap machine. Creating a C 
compiler which produced VAX-11 native-mode assembly code was the first task. The 
code generator portion of the portable C compiler was rewritten to do this. An 
assembler and loader, based on similar code for the Interdata 8/32, completed 
the basic support software. Existing PDP-11/70 device drivers for disk, tape, 
and terminal communication lines were adapted to the VAX-11/780. Assembly 
language interfaces (trap handlers, hardware initialization, etc.) were 
completely rewritten. We then created magnetic tapes in the proper format for an 
initial file system and for deadstart load, and physically carried these tapes 
from the PDP-11/45 to the VAX-11/780. </P>
<P>Work on the C compiler began in mid-December 1977. The hardware arrived on 
March 3. We held a party on May 19 to celebrate successful multiuser operation 
of the system. </P>
<P><B>Performance.</B> Identical documents were formatted by <I>nroff</I> on our 
VAX-11/780 and on a PDP-11/70 running Research version 7 UNIX; both systems used 
RP06 disks. Identical C programs were compiled and assembled on the VAX-11/780 
and on the PDP-11/70. As reported by the <I>time</I> command, the results 
(converted to seconds) were: </P>
<P>
<DIV align=center>
<TABLE>
  <TBODY>
  <TR>
    <TD align=middle colSpan=4>nroff -ms -e -T450-12 ios.r &gt;/dev/null</TD></TR>
  <TR></TR>
  <TR>
    <TD></TD>
    <TD>real</TD>
    <TD>user</TD>
    <TD>sys</TD></TR>
  <TR>
    <TD>VAX-11/780</TD>
    <TD>47.0</TD>
    <TD>28.6</TD>
    <TD>8.7</TD></TR>
  <TR>
    <TD>PDP-11/70</TD>
    <TD>54.0</TD>
    <TD>36.9</TD>
    <TD>7.9</TD></TR></TBODY></TABLE>
<P></P>
<P>
<TABLE>
  <TBODY>
  <TR>
    <TD align=middle colSpan=4>cc -c -O pftn.c</TD></TR>
  <TR>
    <TD></TD>
    <TD align=right>real</TD>
    <TD align=right>user</TD>
    <TD align=right>sys</TD></TR>
  <TR>
    <TD>PDP-11/70 (Ritchie compiler)</TD>
    <TD align=right>86.0</TD>
    <TD align=right>43.5</TD>
    <TD align=right>11.8</TD></TR>
  <TR>
    <TD>VAX-11/780 (portable compiler)</TD>
    <TD align=right>82.0</TD>
    <TD align=right>64.0</TD>
    <TD align=right>10.5</TD></TR>
  <TR>
    <TD>PDP-11/70 (portable compiler </TD>
    <TD align=right rowSpan=2>153.0</TD>
    <TD align=right rowSpan=2>114.6</TD>
    <TD align=right rowSpan=2>16.6</TD></TR>
  <TR>
    <TD align=right>for Interdata 8/32)</TD></TR></TBODY></TABLE></P></DIV>
<P></P>
<P>From the statistics on <I>nroff</I> one should conclude that, based on 
user-mode CPU time, the VAX-11/780 can execute the code produced by the VAX-11 C 
compiler approximately 22% faster than the PDP-11/70 an execute the code 
produced by the PDP-11 C compiler. This is a measure of the combined power of 
the hardware and efficiency of the code generated by the compiler. Except as an 
upper limit, the figures give no indication as to the throughput, response time, 
or efficiency of the operating system. The differences in real time and system 
time between the VAX-11/780 and the PDP-11/70 are not significant. </P>
<P>The times given for compilation of the file <I>pftn.c</I> are an attempt at a 
"black box" comparison of apples and oranges. The black box is any program 
(compiler) which takes C language input and produces executable instructions. 
The black-box comparison is that the current VAX-11 C compiler running on the 
VAX-11/780 and compiling code for the VAX-11 requires 49% more user-mode CPU 
time than the current PDP-11 C compiler running on the PDP-11/70 and compiling 
code for the PDP-11. The apples and oranges aspect arises because the two 
compilers, while equivalent from the black box viewpoint, are (on the inside) 
totally different pieces of software. The PDP-11 compiler is a production 
compiler written by D. M. Ritchie; the VAX-11 compiler is a portable compiler 
based on work by S. C. Johnson. The figures for the portable compiler running on 
the PDP-11/70 and compiling for the Interdata 8/32 are included for those who 
wish to compare two portable compilers. We have no VAX-11 equivalent to the 
Ritchie compiler, and thus cannot run the tests which would enable comparison of 
two production compilers. </P>
<P>The loaded size in bytes of the operating system and seven other programs 
appears in Table 1. One should note the general similarity between the text 
(instructions) sizes on the PDP-11 and on the VAX-11, and between the bss 
(uninitialized data) sizes on the VAX-11 and on the Interdata 8/32. The 
particular PDP-11 UNIX system chosen has several more input/output device 
drivers and experimental multiplexing software not in the VAX-11 system, which 
accounts for its larger text size. If many global integer variables (or large 
arrays) are used, there is a tendency for the data and bss portions to double in 
size when going from a PDP-11 to a VAX-11 or an Interdata 8/32 because an 
<B>int</B> occupies two bytes on the PDP-11 and four bytes on the other 
machines. However, character arrays occupy the same amount of space on all 
machines. An unusually large number of references to global variables in the 
<I>nroff</I> program accounts for its increase in text size on the VAX-11 
compared with the PDP-11. A program can be written to automatically change the 
addressing modes used in the VAX-11 code so that most references to global data 
become shorter than at present, but this has not been done. </P>
<P><B>Evaluation.</B> We believe that the VAX-11/780 provides an excellent 
hardware environment for running UNIX and C software. With the software in its 
current state, we view the system as operationally equivalent to a PDP-11/70 
running UNIX software, except that the 64K limit on process address space is 
gone and programs run faster. We believe that the advanced memory management and 
user/system communication capabilities of the VAX-11/780 offer an opportunity to 
construct future UNIX-like systems with substantially higher throughput than 
provided by today's UNIX on a PDP-11/70. </P>
<H4>3. Details </H4>
<P><B>Hardware</B> </P>
<P>Four main subsystems &#151; the central processor, console, main memory, and 
input/output &#151; constitute the VAX-11/780 computer system. The central processor, 
memory, and input/output subsystems are connected by the Synchronous Backplane 
Interconnect (SBI), an internal synchronous bus with a maximum data throughput 
of 13.3 megabytes per second. The SBI deals in physical addresses which are 30 
bits wide. Half of the SBI address space is reserved for memory addresses, and 
half for input/output device registers. Arbitration for bus cycles on the SBI is 
distributed; each subsystem decides if it will use the next bus cycle. </P>
<P>The central processor is a microprogrammed 32-bit general-register computer. 
The architecture seen by the user-mode assembly-language programmer is 
"culturally compatible" with the PDP-11; an expert programmer familiar with the 
PDP-11 can learn and understand the differences in one day or less. The 
processor handles binary integers of 8, 16, and 32 bits; single precision (32 
bit) and double precision (64 bit) floating-point numbers; character strings up 
to 65535 bytes long; bit fields up to 32 bits wide; and IBM-style packed decimal 
strings up to 31 digits long. Bit fields have no alignment restrictions 
whatsoever, all other data types require alignment only to a byte (8 bit) 
boundary. The central processor provides sixteen 32-bit general registers. 
Register 15 is the program counter <B>pc</B>. Software operating in one of the 
privileged access modes (see below) must use register 14 as a stack pointer 
<B>sp</B>. The instructions which implement high-level procedure call and return 
(<B>pushl</B>, <B>calls</B>, <B>callg</B>, <B>ret</B>) assume a convention about 
the use of <B>sp</B>, register 13 (<B>fp</B>, the frame pointer) and register 12 
(<B>ap</B>, the argument pointer). The instructions which handle character and 
packed decimal strings use registers 0 through 5 to hold pointers and counters, 
so as to be interruptible. Floating-point operations may use the general 
registers; there are no separate floating-point registers. Instructions take 
from zero to six operands. The operation code occupies one byte and is followed 
by the operands, which require from one to nine bytes each. Nine addressing 
modes (including all the PDP-11 modes except *-(r)) are allowed, and the 
addressing modes are independent of the operation code. When the central 
processor is executing in the context of a process, there are four access 
privilege modes (user, supervisor, executive, kernel), each with its own stack 
pointer; software which desires a per-process kernel stack is easy to implement. 
A fifth stack pointer is used when executing in a special system-wide interrupt 
context. The VAX-11/780 processor includes an eight kilobyte, two-way set 
associative, write-through, memory data cache; an eight-byte instruction stream 
buffer; and a 128-address virtual address translation buffer. Most of the 
processor is implemented in Schottky TTL MSI logic. A programmable realtime 
clock and a time-of-year clock (battery operated during loss of line voltage) 
are standard equipment. Options include a hardwired floating-point accelerator 
and user-writeable control store. </P>
<P>The console subsystem consists of an LSI-11 computer, local memory, floppy 
disk, DECwriter terminal, and remote-access communications port. The console is 
connected directly to the central processor and performs all the functions of a 
conventional "lights and switches" front panel. The floppy disk serves as the 
initial bootstrap device for normal operation and holds special microcode for 
diagnostic operation. When activated by a key switch on the central processor, 
the remote-access port becomes the console. A terminal connected through the 
remote-access port can halt the central processor, boot it, diagnose it, etc. 
</P>
<P>The virtual address space of a process running on the VAX-11/780 consists of 
2**32 8-bit bytes. The two high-order bits of a 32-bit address determine one of 
four segments. Two of these segments are system segments common to the address 
space of all processes. One of the system segments is reserved for future use. 
The other two segments are separately defined for each process and are 
automatically managed by the context switching instructions. One of the 
per-process segments is designed for a stack which grows towards lower-numbered 
memory addresses. Segments are divided into pages of 512 bytes. Memory mapping 
hardware translates virtual addresses into physical addresses using page tables. 
A page table contains one four-byte entry for each page mapped; the entry 
contains a valid bit, a four-bit field which encodes access privileges, a modify 
bit, and the physical page-frame number where the page is mapped. (There is no 
reference bit which is maintained by hardware!) A base register and a limit 
register describe the page table of each segment. The base register of a 
per-process segment contains a virtual address within the system segment; the 
base register for the system segment contains a physical memory address. The 
VAX-11/780 central processor contains a virtual address translation buffer 
holding 128 virtual address-page frame number pairs which eliminates the need 
for extra memory references during address translation for (typically) 98% of 
all memory references. The memory is implemented using MOS semiconductor RAMs 
with an error correcting code which corrects all single-bit errors and detects 
all double-bit errors and 70% of all greater-than-double bit errors. A memory 
controller can handle 8 memory boards; using 4K chips each board can hold 128K 
bytes. There can be two memory controllers, thus the maximum amount of physical 
memory is currently 2 megabytes. When 16K chips are used [forecasted for late 
1978], each board will hold 512K, and physical memory can be 8 megabytes. There 
is a battery backup option for maintaining data in the event of a power failure. 
Each optional battery will maintain l megabyte for 10 minutes. </P>
<P>The input/output subsystem consists of UNIBUS adaptors and MASSBUS adaptors. 
A UNIBUS adaptor (UBA) is an interface between a standard UNIBUS and the SBI. 
The UBA does the bus arbitration and everything else necessary to administer the 
UNIBUS. It also contains a set of registers for mapping UNIBUS addresses to and 
from SBI addresses. The maximum throughput on a UBA is 1.5 megabytes per second. 
A MASSBUS adaptor (MBA) is an interface between the SBI and MASSBUS devices 
(RP06 disk, TE16 tape, etc.). An MBA would be more properly called an RH-780 
controller, analogous to the RH-11 controller on a PDP-11/70 MASSBUS; only one 
unit may transfer data at a time, although several similar units connected to 
the same MBA can execute control functions simultaneously. The MBA contains the 
device control registers normally found in an RH controller. The registers lie 
in the I/O section of SBI addresses. An MBA also contains a set of mapping 
registers which translate device byte addresses to and from SBI addresses. The 
maximum throughput on a MBA is 2.0 megabytes per second. The published limits 
are 1 UBA and 4 MBAs per system. Theoretically one could have any number of 
either kind as long as the sum of the number of central processors, memory 
controllers, MBAs, and twice the number of UBAs were 15 or less, since the SBI 
has 15 "ports". </P>
<P>The physical packaging of the system has been dramatically improved compared 
with the PDP-11. The VAX-11/780 processor cabinet contains no drawers or moving 
cables. The SBI is fixed and rigid. Three one-third horsepower squirrel-cage 
blowers provide sufficient air flow &151; even while servicing the CPU. Any logic 
card, power supply, or blower an be replaced within twenty minutes by one person 
using only a screwdriver The CPU stands 1.53m x 1.17m x 0.77m (HWD); cabinets 
housing the CPU, UNIBUS devices, and tape drive are usually bolted together to 
form a single unit 1.53m x 2.51m x 0.77m. Our configuration (see section 2) 
weighs 3452 pounds and requires 42050 BTU/hr cooling. </P>
<H4>C Compiler </H4>
<P>A VAX-11 "native mode" C compiler was constructed using S. C. Johnson's 
portable compiler as a base. After one month, a reasonable version began to 
evolve: it produced code which was good enough to exercise the assembler, 
loader, and debugger (on the bootstrap PDP 11/45). This initial version did not 
make use of VAX-11 indexed addressing (which does single-level array 
subscripting including appropriate index shifts), bit field instructions, or 
autoincrement/decrement addressing. It contained its share of bugs, particularly 
since the hardware had not arrived and could not be used to actually run the 
generated code. </P>
<P>Substantial effort has been subsequently directed towards improving all 
aspects of the compiler: bugs have been corrected, routines have been made to 
execute more efficiently, and the quality of the generated code has been 
improved. All addressing modes are supported, bit field instructions are used 
for programmer-defined bit fields, and autoincrement and autodecrement 
addressing as well as three-address instructions are used. </P>
<P>Overall, our experience with the compiler has been very favorable. When the 
VAX-11/780 was delivered, the compiler worked well enough to compile itself, the 
UNIX kernel, and many user-level commands. In fact, since the delivery of the 
machine, only about a half-dozen serious bugs have been detected. Additionally, 
the framework of the compiler has proven itself to be flexible: a compiler for 
the Interdata 8/32 was transformed into a compiler for the VAX-11/780, some 
improvements and extensions were easily added, and, in general, a quickly 
evolving compiler has remained stable and productive. The authors feel that, 
with a few extensions to the model of the compiler and a certain amount of 
tuning, the current VAX-11 compiler could easily remain as the production VAX-11 
compiler. </P>
<P>There are still some deficiencies in the current version of the compiler, as 
well as in the basic "product" itself. The compiler is slow and quite large; see 
the statistics in section 2 and Table 1. Some of the blame for the size and 
lethargy of the first pass can be attributed to the use of <I>lex</I> for the 
scanner and <I>yacc</I> for the parser, and to the use of ASCII to communicate 
information between passes. both <I>lex</I> and <I>yacc</I> produce large 
routines: the scanner is 17K bytes in length (over 4.5K bytes of instructions), 
and the parser is 16K bytes long (over 5.5K bytes of instructions). On the 
average, the first pass spends 20% of its time in the lexical scanner 
<I>yylook</I>, and 9% of its time in the parser <I>yyparse.</I> </P>
<P>Using ASCII to communicate between the two paves causes an additional speed 
penalty for character conversion. On typical programs, the fast pass (parser) 
spends roughly 30% of its time performing output services (i.e.,, calls to 
<I>_doprnt</I> (18%), <I>_strout</I> (8%), and <I>printf</I> (4%), while the 
second pass (code generator) spends roughly 21% of its time reading it back in 
(i.e., calls to <I>read</I> (18%) and <I>rdin</I> (3%). (Additionally, the 
routine used to convert from ASCII to binary contained a bug which caused 
"-2147483648" (which is -(2**31) ) to be read as zero on our PDP-11/45.) </P>
<P>The above problems are not inherent to the compiler model. To speedup 
compilation, the scanner can be hand-coded (as in the standard PDP-11 compiler), 
and the interpass data can be formatted in binary (or the two passes can be 
combined). With these simple modifications (some are already in progress), it 
should be possible to produce a compiler almost twice as fast as the current 
one. </P>
<P>Two features of the VAX-11 architecture &#151; three-address instructions and 
indexed addressing mode &#151; were difficult to model within the basic structure of 
the compiler. The full implementation of three-address instructions proved to be 
so difficult that it was not really attempted. Instead, <I>c2</I>, the assembly 
language code improver, tries to merge several instructions into an appropriate 
three-address instruction. For example, the statement <I>a = b + c</I> compiles 
<DL>
  <DT>
  <DD><TT><PRE>	addl3	b,c,r0
	movl	r0,a
</PRE></TT></DD></DL>which the improver can change to: 
<DL>
  <DT>
  <DD><TT><PRE>	addl3	b,c,a
</PRE></TT></DD></DL>for a savings of three bytes and over 400 nanoseconds. 
However, <I>c2</I> will not always succeed in this shortening. It cannot tell 
the difference between 
<DL>
  <DT>
  <DD><TT><PRE>	a = b + c
	return;
</PRE></TT></DD></DL>and 
<DL>
  <DT>
  <DD><TT><PRE>	return(a = b + c );
</PRE></TT></DD></DL>since register r0 must be considered "live" (i.e., contains 
a value which may be required later) across the return statement. 
<P></P>
<P>The VAX-11 has six indexed addressing modes which yield the address of an 
element of a one-dimensional array of a base type (<B>char</B>, <B>short</B>, 
<B>int</B>, <B>long</B>, pointer, <B>float</B>, or <B>double</B>). The statement 

<DL>
  <DT>
  <DD><TT><PRE>	a[i] = b[j] * c[k];
</PRE></TT></DD></DL>where <I>i</I>, <I>j</I>, and <I>k</I> are declared 
<B>register int</B> and <I>a</I>, <I>b</I>, and <I>c</I> are <B>double</B> 
arrays (either external or local) can be compiled into the single instruction: 
<DL>
  <DT>
  <DD><TT><PRE>	muld3	b[j],c[k],a[i]
</PRE></TT></DD></DL>Although the index specifier (e.g. <I>i</I> in the above 
example) must be a register, the base address specifier can be any addressing 
mode except register, literal, or another indexed mode. For example, the 
C-language constructs <I>a[i], (*p)[i], (--p)[i], (p++)[i]</I> and 
<I>(*p++)[i]</I> (or their equivalents <I>*(a+i)</I>, <I>*(*p+i)</I>, 
<I>*(--p+i)</I>, <I>*(p++ +i)</I>, and <I>*(*p++ +i)</I>, respectively) all can 
be done with a single VAX-11 address (where a is an array of base type, p is a 
pointer to the same type, and 1 is of type <B>register int</B>). It is usually 
difficult to recognize or conveniently represent such constructs (e.g., 
<I>(-p++)[i]</I> is fun), or generate the possible cases (e.g., <I>a[i]</I> 
where a is not readily addressable). 
<P></P>
<P>The fact that the code generator can easily recognize only expression trees 
of height one (two if OREG and UNARY MUL nodes are taken into account) causes 
substantial difficulty in making use of indexed mode, three address 
instructions, and indirect addressing. Expression trees of non-trivial height 
occur not infrequently (e.g. as a worst case, the statement 
<DL>
  <DT>
  <DD><TT><PRE>	a = b + (*p++)[i];
</PRE></TT></DD></DL>has an expression tree of height six, but can be compiled 
into the single instruction 
<DL>
  <DT>
  <DD><TT><PRE>	addl3	b,*(p) + [i],a
</PRE></TT></DD></DL>if <I>p</I> and <I>i</I> are <B>register</B> variables). 
The complexity of the code generator is raised by forcing the compression of 
subtrees into single nodes which are then treated with special checks, special 
code, etc. 
<P></P>
<P>The size and alignment attributes of data objects are logically independent, 
even though previous hardware architectures (IBM 360, PDP-11, Interdata 8/32, 
...) have imposed alignment restrictions based on size. The VAX 11/780 has no 
such restrictions, although programs run faster with data aligned on natural 
boundaries. The C language has little notion of alignment; because of run-time 
penalties, the VAX-11 C compiler aligns all the basic data types on address 
boundaries which are a multiple of <B>sizeof</B> the basic type. Due to 
questions about alignment, both the language and the compiler have difficulty 
with the declaration <I>char c:10;</I>. </P>
<P>The decision to naturally align most data items has undesirable side effects 
which cannot be ignored. Consider the structure declaration 
<DL>
  <DT>
  <DD><TT><PRE>	struct foo {
	   char c;
	   float f;
	} bar;
</PRE></TT></DD></DL>On the PDP-11, <B>sizeof</B><I>(foo)</I> is 6 bytes while 
on the VAX-11, <B>sizeof</B><I>(foo)</I> is currently 8 bytes (the offset of 
<I>f</I> within <I>bar</I> is 2 and 4 respectively). <B>sizeof</B><I>(foo)</I> 
could be 5 bytes in each case. Although both machines use the same data formats 
for chars and floats, the differing alignment imposed by the the VAX-11 C 
compiler means that the two machines cannot speak directly to one another using 
media which record structures containing binary information. Since alignment is 
important, we feel that it ought to be specifiable in the C language. 
<P></P>
<H4>Operating system conversion </H4>
<P>A UNIX system running on a PDP-11/45 was used as the base for transporting 
software to the VAX-11/780. The software itself originated with the code 
produced by members of Center 127, Computing Science Research, for the Interdata 
8/32. Programs were cross compiled, assembled, loaded, and put an magnetic tape 
in <I>tp</I> format; absolute bit-string files were put on tape in <I>dd</I> 
format. Tapes were then carried across the room to the VAX-11/780. An absolute 
tape boot (in machine language), <I>tp</I> boot and primary disk boot (in 
assembly language), secondary disk boot (in C), and stand-alone utilities (disk 
formatter, disk verifier, tape-to-disk, disk-to-tape , disk-to-disk, and 
disk-to-console, all in C) were then used to bring up the system. </P>
<P>Establishing an initial file system on the disk took longer than expected. 
The PDP-11/45 was running USG issue 3 of the UNIX operating system with a 
"16-bit" file system and the VAX-11/780 was to have a Research version 7 
"32-bit" file system. Also, C-language code on the VAX-11 expects the bytes of a 
32-bit integer to be stored in a different order than C-language code on the 
PDP-11. We swallowed these two red herrings hard, and suffered. We now know that 
the proper way to create an initial file system is to modify the program 
<I>mkfs</I> so that its output (on the bootstrap machine) is a file containing 
the proper bits, put that file on tape, and use the tape-to-disk utility on the 
target machine. </P>
<P>Mapping the software architecture of the UNIX operating system onto the 
hardware architecture of the VAX-11 required a number of decisions. Commentary 
on these decisions follows. The SCB (system context base) processor register 
contains a page-aligned physical memory address which is the base of the 
hardware interrupt vector. The UNIX system puts this vector at physical memory 
address zero. Operating system code, data, kernel stacks, and interrupt stack 
occupy the VAX-11/780 system segment (virtual addresses 80000000 to bffffff). 
User code and data are loaded into segment zero (0 to 3fffffff) and the user 
stack is initialized in segment one (7fffffff to 4000000). User processes pass 
arguments to system service code using the ordinary <I>calls</I> subroutine 
calling sequence. The <B>ckmk</B> instruction is then used to gain kernel 
privileges. The chmk instruction switches the stack pointer <B>sp</B> from the 
user stack to the kernel stack, but does not change the argument pointer 
<B>ap</B> or the frame pointer <B>fp</B>. The kernel uses the value in <B>ap</B> 
to copy the arguments into <I>u.u_arg</I>. The VAX-11 hardware allows the values 
to be directly addressed, but the kernel software requires the copy. </P>
<P>The <I>u area </I>is a per-process data structure in which the operating 
system keeps swappable information about a process. The kernel virtual address 
of the <I>u area</I> must be a constant across all processes. The PDP-11 
implementation puts the <I>u area</I> at kernel address 0160000; when process 
switching occurs the <I>u area</I> is switched by changing a kernel data space 
segmentation register. Since the operating system can address user memory on a 
VAX-11, the <I>u area</I> could be placed in (protected) user memory, say at 
address 0 or at 7fffe000. However, it was desirable for the first implementation 
to make the page tables for user segments part of the <I>u area</I>, which 
creates timing problems unless the <I>u area</I> lies in system space. The base 
of the <I>u area</I> was assigned kernel virtual address 80020000. When process 
switching occurs, the <I>u area</I> is changed by changing the system-space page 
table and invalidating the page-table translation cache for the appropriate 
pages. </P>
<P>Since the operating system can directly address the memory of the current 
user process, the procedures <I>fubyte</I>, <I>subyte</I>, <I>fuword</I>, etc., 
are unnecessary and could be made into macros which would merely do the 
appropriate load or store. However, these procedures (along with <I>copyin</I> 
and <I>copyout</I>) were kept to ensure that each access to user space is valid. 
</P>
<P>A VAX-11/780 internal processor register called the PCB (process context 
base) points to an area in which the VAX-11/780 saves the hardware state of the 
machine (96 bytes) when switching context. This save area was put in the <I>u 
area</I> as <I>u_rsav</I>. </P>
<P>The implementation of context switching required major effort. The VAX-11 has 
two very nice instructions (<B>svpctx</B>, save process context; and 
<B>ldpctx</B>, load process context) which facilitate context switching. 
Unfortunately, they do not implement the mechanism which the UNIX system 
expects. The mechanism used by UNIX is so dispersed and intricately detailed 
that it is hard to imagine any hardware which implements it directly.) The 
temptation to drastically change the UNIX code has been resisted so far. The 
<I>savu/retu/aretu</I> tar pit was VAXinated, but it took more than a week. The 
newer <I>save/restore</I> primitive does make the C-language code prettier, but 
the assembly-language side (at least for the VAX-11) is just as dirty as ever. 
The UNIX context switching mechanism requires three state save areas, 
<I>u.u_rsav</I>, <I>u.u_ssav</I>, and <I>u.u_qsav</I> because the same mechanism 
is also used for abnormal returns. The VAX-11 context-switching instructions use 
only a single state save area. To make use of the VAX-11 instructions, the 
software simulates a great deal of microcode and bastardizes call frames in a 
most ugly manner. Context switching is certainly high on the list of things to 
rewrite in the second implementation (even for the PDP-11!). </P>
<P>The procedures <I>sureg</I> and <I>estabur</I> were also tricky to implement. 
They were designed with the assumption that only a small number (16 or fewer) of 
registers would be needed to map the address space of a user process, while on 
the VAX-11 a 32K process requires 64 page table entries. Furthermore, the memory 
map of a process is diddled in tricky ways, particularly in <I>expand</I> and 
<I>getxfile</I>. </P>
<P>Handling DMA I/O hardware was the other major implementation bottleneck. The 
UBA and MBA mapping registers contain physical memory page numbers, and physical 
addresses are hard to handle. It is not pleasant to deal with the hardware which 
implements the mapping registers. If an I/O transfer is in progress then the 
mapping registers may be neither read nor written; this applies even to 
registers which would not be used by the transfer. As a result, the map for the 
next I/O operation cannot be setup during the current I/O operation. 
Furthermore, a single transfer is limited to 64K bytes because the byte counter 
is only 16 bits wide. Thus swapping a process to the disk can require multiple 
I/O operations. The solution to these problems involved permanently reserving 
the last 129 registers in each map to service both swap and physical I/O 
operations. The remaining map registers are available to map the system buffers, 
and are loaded at system initialization time. Disk ECC error correction is 
currently done only for I/O involving the system buffers. Disk errors on raw I/O 
cause process termination; the swap area on disk had better be error-free. </P>
<P>Like the UNIX system for the PDP-11, the current implementation for the 
VAX-11/780 maintains each process in contiguous physical memory and swaps 
processes to disk when there is not enough physical memory to contain them all. 
Reducing external memory fragmentation to zero by utilizing the VAX-11/780 
memory mapping hardware for scatter loading is high on the list of things to do 
in the second implementation pass. To simplify kernel memory allocation, the 
size of the user-segment memory map is an assembly parameter which currently 
allows three pages of page table or 192K bytes total for text, data, and stack. 
This also deserves to be rewritten, both to allow varying process size, and to 
allow processes larger than physical memory through demand paging. Dynamic page 
table size would mean dynamic <I>u area</I> size if the page table remained part 
of the <I>u area</I>. </P>
<P>The code in <I>sendsig</I> for sending a signal to a process involves a 
tedious simulation of the calls instruction due to the problem of "inward 
return" across privilege modes upon termination of the routine which handles the 
signal. Making a portion of the kernel code readable by a user-mode process 
would simplify sendsig. Motivated by a problem with the Bourne shell, the signal 
number is passed as a parameter to the signalled routine. </P>
<P>Interprocess communication via signals (<I>signal</I> and <I>kill</I>) uses 
the low-order bit of a machine address for something other than addressing. This 
implies that a procedure which handles signals must start on an even byte 
boundary, which means that every procedure must start on an even byte boundary. 
The C compiler thus issues a pseudo-op to the assembler to align the beginning 
of each procedure. This can waste memory on a VAX-11. It also imposes a 
nontrivial requirement on the assembler, since if the resolution of conditional 
jump instructions can change the parity of the length of a procedure then the 
alignment directive must also be handled like a conditional jump. In hindsight, 
it would have been better if a distinct value (say +1 or -1) were used for 
<I>ignore</I>, rather than multiplexing the bottom bit. </P>
<P>The VAX-11/780 provides a (non-maskable) trap for integer division by zero. 
The system would like to turn this into a signal to the process. A similar 
situation exists for subscript range trap. Integer overflow, floating overflow, 
floating underflow, and reserved operand also need signal numbers. Perhaps only 
one "error" signal is needed with some other means for determining the true 
fault. The whole business of interrupts, signals, asynchronous I/O, and the use 
of the hardware AST mechanism deserves more attention. </P>
<P>A bug was discovered in the UNIX code for process termination involving the 
<I>proc</I> and <I>xproc</I> structures. (The problem also existed on the 
PDP-11, but it would only be noticed if a process had accumulated more than 
65535 ticks of system time, which is highly unlikely.) When a process dies its 
resource utilization statistics (currently only exit status, system, and process 
CPU time) are temporarily saved so that they can be added to the totals for the 
descendents of the parent process. The actual accumulation is done by the kernel 
when the parent process issues a wait system call; the child process is then 
completely erased. The kernel was overlaying the statistics in a part of the 
<I>proc</I> structure normally used by the scheduler to contain the pointer 
<I>p_textp</I>. Ordinarily the exit was processed immediately, causing no harm. 
But if the system was loaded so that swapping was necessary, then the scheduler 
could sneak in after the child exited and before the parent read the statistics, 
and would interpret the timing data in the zombie <I>xproc</I> structure as a 
pointer. This invariably caused an illegal memory reference from kernel mode on 
the VAX-11/780. </P>
<P>One of the greatest disappointments with the current system stems from a 
design quirk in the FP-11 floating-point processor for the PDP-11. When 
converting between floating-point and 32-bit integer, the FP-11 expects the 
high-order 16 bits of the integer to be stored at the lower memory address; this 
is not in line with the general "right to left" design of the PDP-11, which 
would place the low-order 16 bits in the lower memory address. C code for the 
PDP-11 uses the FP-11 convention for storing <B>long</B> integers. The VAX-11 
hardware stores the least significant bit of <I>any</I> integer data type in the 
lowest addressed byte. C code for the VAX-11 uses the hardware convention. This 
means that files containing <B>long</B> integers represented in the local 
convention are not binary compatible between a UNIX system on the VAX-11 and a 
UNIX system on the PDP-11. This is the only exception for data types common to 
both machines: <B>char</B>, <B>short</B>, <B>float</B>, and <B>double</B> all 
have a common representation. Except for this (and the structure alignment 
problem noted earlier), disk packs containing 32-bit file systems, tapes, etc., 
would have been interchangeable. The fact that DEC's Fortran-IV Plus for the 
PDP-11 avoided the FP-11 convention, and that RSX-11 files <I>are</I> binary 
compatible between the VAX-11 and the PDP-11, is only salt on an open wound! 
</P>
<H4>Subroutine libraries </H4>
<P><B>libc.</B> Conversion of the system-call interface routines was 
straightforward but tedious. Most routines are merely 
<DL>
  <DT>
  <DD><TT><PRE>	.word	0x0000
	chmk	$nn
	bcc	L1
	jmp	cerror
   L1:	ret
</PRE></TT></DD></DL>The routines <I>printf</I>, <I>ecvt</I>, and <I>fcvt</I>, 
were left to <B>libS</B> and were not implemented in <B>libc</B>. 
<P></P>
<P><B>libS.</B> Conversion of the standard input/output library <B>libS</B> 
posed no problems except for <I>_doprnt</I>, the routine which constructs 
character representations of other datatypes for the printing routines 
<I>printf</I>, <I>fprintf</I>, and <I>sprintf</I>. Since many programs spend 15% 
to 20% of their execution time within <I>_doprnt</I>, it pays to code the 
routine for speed in assembly language. Packed-decimal instructions handle 
decimal, unsigned, and floating-point conversions. The algorithm chosen for 
converting from floating-point to character string revealed a microcode bug in 
the VAX-11/780's <B>ashp</B> (arithmetic shift and round packed) instruction. 
Under certain conditions a carry from the rounded digit propagated both to the 
adjacent digit and to the digit eight places further left. This usually caused 
an overflow, since the destination packed-decimal string was typically not long 
enough to represent the spurious carry. DEC claims to have a fix for the bug, 
but the FCO has not arrived. In the meantime a five-instruction patch detects 
and corrects the spurious overflow. </P>
<H4>Commands </H4>
<P><B>as, ld.</B> Code developed by Center 127 for the Interdata 8/32 was the 
model for an interpretation by a VAX-11/780 artist. The assembler uses an 
algorithm described in [3] with heuristic improvement of [4] to resolve 
conditional jump pseudoinstructions. Variable-length, unaligned instructions and 
address constants forced the relocation information in object tiles to include 
the explicit segment-relative address for each relocatable datum, rather than 
deducing the address from a one-to-one correspondence between the position in 
the segment and the corresponding position in the relocation table. This caused 
a slight change in the header information within object files. </P>
<P><B>c2.</B> The code improver for the assembly language generated by the 
VAX-11 C compiler is based on a similar program for the PDP-11. A "backwards" 
register usage pass, performed once and before anything else, was a major 
addition. Knowing that no temporary register is live across a backwards jump, 
the register usage pass introduces three-address instructions wherever possible. 
It also recognizes situations where jump on bit (<B>jbc</B>, <B>jbs</B>, 
<B>jlbc</B>, <B>jlbs</B>), extract field (<B>extzv</B>, <B>movzbl</B>), and move 
address (<B>moval</B>, <B>movab</B>, <B>pushal</B>, <B>pushab</B>) instructions 
can be used. The code for insertion of fancy loop control instructions 
<B>sob</B>, <B>sob</B>, <B>scb</B> was also extended. </P>
<P><B>adb.</B> The most significant change to the symbolic debugging routine was 
the writing of a disassembles for VAX-11 native-mode instructions. Additionally, 
the character input and output routines were modified to use a default radix for 
all numeric values. The radix is initialized to sixteen. </P>
<P><B>sh.</B> The (Bourne) shell is the standard user command interpreter. It 
required by far the largest conversion effort of any supposedly portable 
program, for the simple reason that it is not portable. Critical portions are 
coded in assembly language and had to be painstakingly rewritten. The shell uses 
its own <I>sbrk</I> which is functionally different from the standard routine in 
<B>libc</B>. The shell wants the routine which fields a signal to be passed a 
parameter giving the number of the signal being caught; signal was also a 
private routine. This was handled by having the operating system provide the 
parameter in the first place, doing away with the private code for 
<I>signal</I>. The code in <I>fixargs</I> (for constructing the argument list to 
an <B>exec</B> system call) had to be diddled. </P>
<P><B>ps, iostat.</B> The process and input/output status commands consistently 
referenced <I>/dev/mem</I> (physical memory) when they should have referred to 
<I>/dev/kmem</I> (kernel virtual memory). <I>iostat</I> also assumed that 
certain variables maintained by the kernel were allocated contiguously, even 
though they were not declared as part of a structure. </P>
<P><B>pr.</B> The command which formats and prints files had a bug that caused a 
division by zero when it was asked to print several files and the fist file in 
the list did not exist. On a PDP-11 division by zero returns the dividend, but 
on a VAX-11 it gives an unmaskable trap. </P>
<P><B>cat, dc.</B> These two commands did not count their arguments using the 
first parameter <I>argc</I>, but rather assumed that an additional argument 
(<I>argv[argc]</I>, initialized as -1) could be used as a pointer. On the PDP-11 
the resulting address references the fixed end of the stack; on the VAX-11, -1 
is an illegal address. </P>
<P><B>nroff/troff</B> The source code for the document preparation and 
phototypesetter commands is not portable; several weeks were required to produce 
properly running version of these commands. Use of the explicit (or worse, 
implicit) constant "2" instead of <B>sizeof</B>(<B>int</B>) was quite common. 
The code assumes that variables which are adjacent in external declarations 
occupy contiguous memory at execution time. Several tables are initialized by 
assembly-language programs. Converting the tables was merely tedious; changing 
the code which thought it knew the format of an <I>a.out</I> file required some 
effort. This memorandum was created using the converted nroff/troff programs on 
the VAX-11/780. </P>
<P><B>SCCS.</B> Version 4 of the Source Code Control System [5] is used to 
provide version backup for software in case disastrous bugs are introduced. The 
source for SCCS itself had not quite been converted to version 7 UNIX, and the 
header files required some massaging. The PWB routines <I>logname</I> and 
<I>pexec</I> had to be simulated. The utility procedures for dynamic storage 
allocation required some work to integrate them with libS and to remove PDP-11 
dialect. The exit status of the <I>diff</I> command changed in version 7, 
causing <I>delta</I> to bomb. The code implicitly assumed that all checksums 
were computed modulo 65536. The documentation is incorrect: everywhere "99999" 
appears it should really say "65535". The procedure <I>satoi</I> returns two 
values, storing one of them indirectly through a pointer parameter. Naturally, 
<I>satoi</I> and its callers did not agree on <B>sizeof</B> the stored value; 
this took a day to track down. </P>
<H4>4. Software portability </H4>
<P>We thank the members of Center 127, Computing Science Research, for their 
efforts in producing the basic software and for their recent efforts towards 
making the software portable. The fact that people other than the original 
developers an quickly create a running system for a new machine is a tribute to 
how well the original work was done. </P>
<P>Yet in our effort to transport a complete UNIX system to the VAX-11/780 we 
stumbled across a large number of nonportable constructions and were dismayed by 
the seeming lack of appropriate facilities to detect and prevent them. Based on 
our experience, we strongly recommend that the C language and its compilers be 
enhanced so that </P>
<DL compact>
  <DT>1.
  <DD>The actual arguments in a procedure call are type checked against the 
  procedure declaration, and a "dummy" declaration which specifies types is 
  permitted even if the called procedure is not actually declared in the same 
  compilation. 
  <DT>2.
  <DD>The '-&gt;' operator is checked to insure that the structure element on 
  the right is a member of a structure to which the pointer on the left may 
  point. 
  <DT>3.
  <DD>A structure element may be declared with any name as long as the name is 
  unique within the immediately surrounding structure. (The current requirement 
  that a structure element name must uniquely correspond to an offset from the 
  beginning of the structure, across all structures in a compilation, creates 
  naming problems and frequently leads to errors of the type noted in item 2 
  above.) 
  <DT>4.
  <DD>The issue of alignment to an even-byte (or other) boundary is brought into 
  the open, so that arbitrary data structures can be accurately described. 
</DD></DL>
<P>There is a program called <I>lint</I> [6] which, if conscientiously used 
throughout the life of a piece of software provides type checking which 
partially addresses the first two points in the above list. The problem is that 
<I>lint</I> is big, noisy, relatively recent and unknown, and (partially as a 
result) infrequently used. There is little incentive for the average programmer 
to use <I>lint</I> as a matter of course. The authors believe that type checking 
belongs in the everyday compiler as the default, where it is very inexpensive to 
implement. Those who wish to do "dirty" work may request that type checking be 
disabled; those who wish to bless their dirty work may use type casts. </P>
<P>We believe that these four enhancements would go a long way towards making C 
language software portable as a rule rather than as an exception, thus 
preserving Bell Laboratories' investment in present and future C software. </P>
<P><I>Acknowledgements.</I> Thank you, D. M. Ritchie and S. C. Johnson, for 
answering questions at key moments; G. K. Swanson, for assistance with boot 
procedures and stand-alone utilities; J. F Jarvis, for the mathematical function 
library; and D. K. Sharma, for help in bringing up user-level commands. 
Additional thanks go to many other members of Centers 127 and 135, and 
Department 8234, for helpful comments and suggestions. </P>
<H4>References </H4>
<P></P>
<DL compact>
  <DT>1.
  <DD>Digital Equipment Corporation, <I>VAX-11/780 Architecture Handbook</I>, 
  Maynard, Massachusetts, 1977. 
  <DT>2.
  <DD>D. M. Ritchie and K. Thompson, The UNIX Time-Sharing System, CACM 
  <I>17</I>, 7 (July 1974), 365-375. See also BSTJ <I>57</I>, 6 (July-August 
  1978), 1905-1929. 
  <DT>3.
  <DD>W. Wulf, R. K. Johnsson, C. B. Weinstock, S. O. Hobbs, and C. M. Geschke, 
  <I>The Design of an Optimizing Compiler</I>, American Elsevier, New York, 
  1975. 
  <DT>4.
  <DD>J. F. Reiser, Common Instances of Pathological Span-dependent 
  Instructions, TM 78-1353-3. 
  <DT>5.
  <DD><I>SCCS/PWB User's Manual, The Source Code Control System.</I> 
  <DT>6.
  <DD>S. C. Johnson, <I>lint</I>, a C Program Checker. Computing Science 
  Technical Report #65, Bell Laboratories, December 1977. </DD></DL>
<DIV align=center>
<P>
<TABLE cellPadding=3>
  <TBODY>
  <TR>
    <TD>Program</TD>
    <TD>System</TD>
    <TD align=right>Text</TD>
    <TD align=right>Data</TD>
    <TD align=right>Bss</TD>
    <TD align=right>Total</TD></TR>
  <TR>
    <TD>/unix</TD></TR>
  <TR>
    <TD></TD>
    <TD>PDP-11</TD>
    <TD align=right>48064</TD>
    <TD align=right>2470</TD>
    <TD align=right>44040</TD>
    <TD align=right>94574</TD></TR>
  <TR>
    <TD></TD>
    <TD>VAX-11</TD>
    <TD align=right>34476</TD>
    <TD align=right>4292</TD>
    <TD align=right>39448</TD>
    <TD align=right>78216</TD></TR>
  <TR>
    <TD></TD>
    <TD>Interdata 8/32</TD>
    <TD align=right>79976</TD>
    <TD align=right>11904</TD>
    <TD align=right>39208</TD>
    <TD align=right>131088</TD></TR>
  <TR>
    <TD>C, pass 1</TD></TR>
  <TR>
    <TD></TD>
    <TD>PDP-11</TD>
    <TD align=right>36736</TD>
    <TD align=right>19826</TD>
    <TD align=right>17656</TD>
    <TD align=right>74218</TD></TR>
  <TR>
    <TD></TD>
    <TD>VAX-11</TD>
    <TD align=right>37520</TD>
    <TD align=right>29492</TD>
    <TD align=right>23512</TD>
    <TD align=right>90524</TD></TR>
  <TR>
    <TD></TD>
    <TD>Interdata 8/32</TD>
    <TD align=right>60606</TD>
    <TD align=right>32192</TD>
    <TD align=right>24920</TD>
    <TD align=right>117718</TD></TR>
  <TR>
    <TD>C, pass 2</TD></TR>
  <TR>
    <TD></TD>
    <TD>PDP-11</TD>
    <TD align=right>21248</TD>
    <TD align=right>6254</TD>
    <TD align=right>5246</TD>
    <TD align=right>32748</TD></TR>
  <TR>
    <TD></TD>
    <TD>VAX-11</TD>
    <TD align=right>23408</TD>
    <TD align=right>9092</TD>
    <TD align=right>7552</TD>
    <TD align=right>40052</TD></TR>
  <TR>
    <TD></TD>
    <TD>Interdata 8/32</TD>
    <TD align=right>35652</TD>
    <TD align=right>9032</TD>
    <TD align=right>7560</TD>
    <TD align=right>52244</TD></TR>
  <TR>
    <TD>ed</TD></TR>
  <TR>
    <TD></TD>
    <TD>PDP-11</TD>
    <TD align=right>10752</TD>
    <TD align=right>302</TD>
    <TD align=right>4390</TD>
    <TD align=right>15444</TD></TR>
  <TR>
    <TD></TD>
    <TD>VAX-11</TD>
    <TD align=right>11552</TD>
    <TD align=right>212</TD>
    <TD align=right>4556</TD>
    <TD align=right>16320</TD></TR>
  <TR>
    <TD></TD>
    <TD>Interdata 8/32</TD>
    <TD align=right>21886</TD>
    <TD align=right>480</TD>
    <TD align=right>4576</TD>
    <TD align=right>26942</TD></TR>
  <TR>
    <TD>grep</TD></TR>
  <TR>
    <TD></TD>
    <TD>PDP-11</TD>
    <TD align=right>4736</TD>
    <TD align=right>408</TD>
    <TD align=right>1906</TD>
    <TD align=right>7050</TD></TR>
  <TR>
    <TD></TD>
    <TD>VAX-11</TD>
    <TD align=right>4864</TD>
    <TD align=right>476</TD>
    <TD align=right>1936</TD>
    <TD align=right>7276</TD></TR>
  <TR>
    <TD></TD>
    <TD>Interdata 8/32</TD>
    <TD align=right>11950</TD>
    <TD align=right>1160</TD>
    <TD align=right>1936</TD>
    <TD align=right>15046</TD></TR>
  <TR>
    <TD>ls</TD></TR>
  <TR>
    <TD></TD>
    <TD>PDP-11</TD>
    <TD align=right>7104</TD>
    <TD align=right>768</TD>
    <TD align=right>3856</TD>
    <TD align=right>11728</TD></TR>
  <TR>
    <TD></TD>
    <TD>VAX-11</TD>
    <TD align=right>6884</TD>
    <TD align=right>1140</TD>
    <TD align=right>5764</TD>
    <TD align=right>13788</TD></TR>
  <TR>
    <TD></TD>
    <TD>Interdata 8/32</TD>
    <TD align=right>15660</TD>
    <TD align=right>1920</TD>
    <TD align=right>5768</TD>
    <TD align=right>23348</TD></TR>
  <TR>
    <TD>nroff</TD></TR>
  <TR>
    <TD></TD>
    <TD>PDP-11</TD>
    <TD align=right>29312</TD>
    <TD align=right>6684</TD>
    <TD align=right>7842</TD>
    <TD align=right>43838</TD></TR>
  <TR>
    <TD></TD>
    <TD>VAX-11</TD>
    <TD align=right>36360</TD>
    <TD align=right>9408</TD>
    <TD align=right>10636</TD>
    <TD align=right>58836</TD></TR>
  <TR>
    <TD></TD>
    <TD>Interdata 8/32</TD>
    <TD align=middle>&#150;</TD>
    <TD align=middle>&#150;</TD>
    <TD align=middle>&#150;</TD>
    <TD align=middle>&#150;</TD></TR>
  <TR>
    <TD>sort</TD></TR>
  <TR>
    <TD></TD>
    <TD>PDP-11</TD>
    <TD align=right>6656</TD>
    <TD align=right>1578</TD>
    <TD align=right>2104</TD>
    <TD align=right>10338</TD></TR>
  <TR>
    <TD></TD>
    <TD>VAX-11</TD>
    <TD align=right>6580</TD>
    <TD align=right>1764</TD>
    <TD align=right>2788</TD>
    <TD align=right>11132</TD></TR>
  <TR>
    <TD></TD>
    <TD>Interdata 8/32</TD>
    <TD align=right>13886</TD>
    <TD align=right>2208</TD>
    <TD align=right>2792</TD>
    <TD align=right>18886</TD></TR></TBODY></TABLE></P>
<P>Table 1. Loaded Program Sizes (in bytes) </P></DIV><A 
href="http://www.lucent.com/copyright.html">Copyright</A> &copy;
 1978 AT&amp;T, 2003 Lucent 
Technologies Inc. All rights reserved. </BODY></HTML>
