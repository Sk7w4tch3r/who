!<arch>
brk.r           362839384   9     1     100666  230       `
include globdefs
include roffdefs
# brk _ end current filled line
	subroutine brk
	include cout

	if (outp > 0) {
		outbuf(outp) = NEWLINE
		outbuf(outp+1) = EOS
		call put(outbuf)
		}
	outp = 0
	outw = 0
	outwds = 0
	return
	end
center.r        362839403   9     1     100666  214       `
include globdefs
include roffdefs
# center _ center a line by setting tival
	subroutine center(buf)
	character buf(ARB)
	integer max, width
	include cparam

	tival = max((rmval+tival-width(buf))/2, 0)
	return
	end
comand.r        362839390   9     1     100666  1358      `
include globdefs
include roffdefs
# comand _ perform formatting command
	subroutine comand(buf)
	character buf(MAXLINE)
	integer comtyp, getval, max
	integer argtyp, ct, spval, val
	include cpage
	include cparam

	ct = comtyp(buf)
	if (ct == UNKNOWN)	# ignore unknown commands
		return
	val = getval(buf, argtyp)
	if (ct == FI) {
		call brk
		fill = YES
		}
	else if (ct == NF) {
		call brk
		fill = NO
		}
	else if (ct == BR)
		call brk
	else if (ct == LS)
		call set(lsval, val, argtyp, 1, 1, HUGE)
	else if (ct == CE) {
		call brk
		call set(ceval, val, argtyp, 1, 0, HUGE)
		}
	else if (ct == UL)
		call set(ulval, val, argtyp, 0, 1, HUGE)
	else if (ct == HE)
		call gettl(buf, header)
	else if (ct == FO)
		call gettl(buf, footer)
	else if (ct == BP) {
		if (lineno > 0)
			call space(HUGE)
		call set(curpag, val, argtyp, curpag+1, -HUGE, HUGE)
		newpag = curpag
		}
	else if (ct == SP) {
		call set(spval, val, argtyp, 1, 0, HUGE)
		call space(spval)
		}
	else if (ct == IN) {
		call set(inval, val, argtyp, 0, 0, rmval-1)
		tival = inval
		}
	else if (ct == RM)
		call set(rmval, val, argtyp, PAGEWIDTH, tival+1, HUGE)
	else if (ct == TI) {
		call brk
		call set(tival, val, argtyp, 0, 0, rmval)
		}
	else if (ct == PL) {
		call set(plval, val, argtyp, PAGELEN,
		   m1val+m2val+m3val+m4val+1, HUGE)
		bottom = plval - m3val - m4val
		}
	return
	end
comtyp.r        362839395   9     1     100666  965       `
include globdefs
include roffdefs
# comtyp _ decode command type
	integer function comtyp(buf)
	character buf(MAXLINE)

	if (buf(2) == LETF & buf(3) == LETI) 
		comtyp = FI
	else if (buf(2) == LETN & buf(3) == LETF) 
		comtyp = NF
	else if (buf(2) == LETB & buf(3) == LETR) 
		comtyp = BR
	else if (buf(2) == LETL & buf(3) == LETS) 
		comtyp = LS
	else if (buf(2) == LETB & buf(3) == LETP) 
		comtyp = BP
	else if (buf(2) == LETS & buf(3) == LETP) 
		comtyp = SP
	else if (buf(2) == LETI & buf(3) == LETN) 
		comtyp = IN
	else if (buf(2) == LETR & buf(3) == LETM) 
		comtyp = RM
	else if (buf(2) == LETT & buf(3) == LETI) 
		comtyp = TI
	else if (buf(2) == LETC & buf(3) == LETE) 
		comtyp = CE
	else if (buf(2) == LETU & buf(3) == LETL) 
		comtyp = UL
	else if (buf(2) == LETH & buf(3) == LETE) 
		comtyp = HE
	else if (buf(2) == LETF & buf(3) == LETO) 
		comtyp = FO
	else if (buf(2) == LETP & buf(3) == LETL) 
		comtyp = PL
	else
		comtyp = UNKNOWN
	return
	end

cout            362839388   9     1     100666  282       `
common /cout/ outp, outw, outwds, outbuf(MAXOUT)
   integer outp		# last char position in outbuf; init = 0
   integer outw		# width of text currently in outbuf; init = 0
   integer outwds		# number of words in outbuf; init = 0
   character outbuf		# lines to be filled collect here
cpage           362839373   9     1     100666  713       `
common /cpage/ curpag, newpag, lineno, plval, m1val, m2val, m3val, m4val, 
	bottom, header(MAXLINE), footer(MAXLINE)
   integer curpag	# current output page number; init = 0
   integer newpag	# next output page number; init = 1
   integer lineno	# next line to be printed; init = 0
   integer plval	# page length in lines; init = PAGELEN = 66
   integer m1val	# margin before and including header
   integer m2val	# margin after header
   integer m3val	# margin after last text line
   integer m4val	# bottom margin, including footer
   integer bottom	# last live line on page, = plval-m3val-m4val
   character header	# top of page title; init = NEWLINE
   character footer	# bottom of page title; init = NEWLINE

cparam          362839389   9     1     100666  436       `
common /cparam/ fill, lsval, inval, rmval, tival, ceval, ulval
   integer fill		# fill if YES; init = YES
   integer lsval	# current line spacing; init = 1
   integer inval	# current indent; >= 0; init = 0
   integer rmval	# current right margin; init = PAGEWIDTH = 60
   integer tival	# current temporary indent; init = 0
   integer ceval	# number of lines to center; init = 0
   integer ulval	# number of lines to underline; init = 0
format.r        362839390   9     1     100666  372       `
include globdefs
include roffdefs
# format _ text formatter main program (final version)
	character inbuf(INSIZE)
	integer getlin
	include cpage

	call init
	while (getlin(inbuf, STDIN) != EOF)
		if (inbuf(1) == COMMAND)	# it's a command
			call comand(inbuf)
		else					# it's text
			call text(inbuf)
	if (lineno > 0)
		call space(HUGE)			# flush last output
	stop
	end
gettl.r         362839394   9     1     100666  408       `
include globdefs
include roffdefs
# gettl _ copy title from buf to ttl
	subroutine gettl(buf, ttl)
	character buf(MAXLINE), ttl(MAXLINE)
	integer i

	i = 1				# skip command name
	while (buf(i) != BLANK & buf(i) != TAB & buf(i) != NEWLINE)
		i = i + 1
	call skipbl(buf, i)		# find argument
	if (buf(i) == SQUOTE | buf(i) == DQUOTE)	# strip quote if found
		i = i + 1
	call scopy(buf, i, ttl, 1)
	return
	end
getval.r        362839396   9     1     100666  421       `
include globdefs
include roffdefs
# getval _ evaluate optional numeric argument
	integer function getval(buf, argtyp)
	character buf(MAXLINE)
	integer ctoi
	integer argtyp, i

	i = 1				# skip command name
	while (buf(i) != BLANK & buf(i) != TAB & buf(i) != NEWLINE)
		i = i + 1
	call skipbl(buf, i)		# find argument
	argtyp = buf(i)
	if (argtyp == PLUS | argtyp == MINUS)
		i = i + 1
	getval = ctoi(buf, i)
	return
	end

getwrd.r        362839392   9     1     100666  406       `
include globdefs
include roffdefs
# getwrd _ get non-blank word from in(i) into  out, increment i
	integer function getwrd(in, i, out)
	integer in(MAXLINE), out(MAXLINE)
	integer i, j

	while (in(i) == BLANK | in(i) == TAB)
		i = i + 1
	j = 1
	while (in(i) != EOS & in(i) != BLANK & in(i) != TAB & in(i) != NEWLINE) {
		out(j) = in(i)
		i = i + 1
		j = j + 1
		}
	out(j) = EOS
	getwrd = j - 1
	return
	end
globdefs        362839383   9     1     100666  1868      `
define	STDIN	0
define	STDOUT	1
define	ERROUT	2
define	READ	0
define	WRITE	2
define	READWRITE	2

define	character	integer
define	LETTER	1
define	DIGIT	2
define	OTHER	3
define	YES	1
define	NO	0
define  OK	0
define	MAXLINE	100
define	ARB	100

define	EOF	-3
define	ERR	-1
define	EOS	-2

define	BACKSPACE	8
define	TAB	9
define	NEWLINE	10
define	BLANK	32	# octal 40
define	BANG	33
define	DQUOTE	34
define	SHARP	35
define	DOLLAR	36	# 44/8
define	PERCENT	37
define  AND 	38
define	SQUOTE	39
define	LPAREN	40
define	RPAREN	41
define	STAR	42
define	PLUS	43
define	COMMA	44
define	MINUS	45
define	PERIOD	46
define  SLASH	47
define	COLON	58
define	SEMICOL	59
define	LESS	60
define  EQUALS	61
define	GREATER	62
define  QMARK	63
define	ATSIGN	64
define	LBRACK	91
define	BACKSLASH	92
define	RBRACK	93
define	UNDERLINE	95
define	LBRACE	123
define	BAR	124
define	RBRACE	125

define	LETA	97
define	LETB	98
define	LETC	99
define	LETD	100
define	LETE	101
define	LETF	102
define	LETG	103
define	LETH	104
define	LETI	105
define	LETJ	106
define	LETK	107
define	LETL	108
define	LETM	109
define	LETN	110
define	LETO	111
define	LETP	112
define	LETQ	113
define	LETR	114
define	LETS	115
define	LETT	116
define	LETU	117
define	LETV	118
define	LETW	119
define	LETX	120
define	LETY	121
define	LETZ	122
define	BIGA	65
define	BIGB	66
define	BIGC	67
define	BIGD	68
define	BIGE	69
define	BIGF	70
define	BIGG	71
define	BIGH	72
define	BIGI	73
define	BIGJ	74
define	BIGK	75
define	BIGL	76
define	BIGM	77
define	BIGN	78
define	BIGO	79
define	BIGP	80
define	BIGQ	81
define	BIGR	82
define	BIGS	83
define	BIGT	84
define	BIGU	85
define	BIGV	86
define	BIGW	87
define	BIGX	88
define	BIGY	89
define	BIGZ	90
define	DIG0	48
define	DIG1	49
define	DIG2	50
define	DIG3	51
define	DIG4	52
define	DIG5	53
define	DIG6	54
define	DIG7	55
define	DIG8	56
define	DIG9	57

define	open	fopen
define	getarg	gtarg
define	seek	fseek
init.r          362839373   9     1     100666  494       `
include globdefs
include roffdefs
# init _ set parameters to default values
	subroutine init

	include cparam
	include cpage
	include cout

	inval = 0
	rmval = PAGEWIDTH
	tival = 0
	lsval = 1
	fill = YES
	ceval = 0
	ulval = 0
	lineno = 0
	curpag = 0
	newpag = 1
	plval = PAGELEN
	m1val = 3; m2val = 2; m3val = 2; m4val = 3
	bottom = plval - m3val - m4val
	header(1) = NEWLINE; header(2) = EOS	# initial titles
	footer(1) = NEWLINE; footer(2) = EOS
	outp = 0
	outw = 0
	outwds = 0

	return
	end
leadbl.r        362839401   9     1     100666  411       `
include globdefs
include roffdefs
# leadbl _ delete leading blanks, set tival
	subroutine leadbl(buf)
	character buf(MAXLINE)
	integer max
	integer i, j
	include cparam

	call brk
	for (i = 1; buf(i) == BLANK; i = i + 1)	# find 1st non\(hyblank
		;
	if (buf(i) != NEWLINE)
		tival = i - 1
	for (j = 1; buf(i) != EOS; j = j + 1) {	# move line to left
		buf(j) = buf(i)
		i = i + 1
		}
	buf(j) = EOS
	return
	end

pfoot.r         362839397   9     1     100666  201       `
include globdefs
include roffdefs
# pfoot _ put out page footer
	subroutine pfoot
	include cpage

	call skip(m3val)
	if (m4val > 0) {
		call puttl(footer, curpag)
		call skip(m4val-1)
		}
	return
	end

phead.r         362839396   9     1     100666  267       `
include globdefs
include roffdefs
# phead _ put out page header
	subroutine phead
	include cpage

	curpag = newpag
	newpag = newpag + 1
	if (m1val > 0) {
		call skip(m1val-1)
		call puttl(header, curpag)
		}
	call skip(m2val)
	lineno = m1val + m2val + 1
	return
	end

put.r           362839373   9     1     100666  461       `
include globdefs
include roffdefs
# put _ put out line with proper spacing and indenting
	subroutine put(buf)
	character buf(MAXLINE)
	integer min
	integer i
	include cpage
	include cparam

	if (lineno == 0 | lineno > bottom)
		call phead
	for (i = 1; i <= tival; i = i + 1)		# indenting
		call putc(BLANK)
	tival = inval
	call putlin(buf, STDOUT)
	call skip(min(lsval-1, bottom-lineno))
	lineno = lineno + lsval
	if (lineno > bottom)
		call pfoot
	return
	end

puttl.r         362839400   9     1     100666  303       `
include globdefs
include roffdefs
# puttl _ put out title line with optional page number
	subroutine puttl(buf, pageno)
	character buf(MAXLINE)
	integer pageno
	integer i

	for (i = 1; buf(i) != EOS; i = i + 1)
		if (buf(i) == PAGENUM)
			call putdec(pageno, 1)
		else
			call putc(buf(i))
	return
	end

putwrd.r        362839393   9     1     100666  777       `
include globdefs
include roffdefs
# putwrd _ put a word in outbuf; includes margin justification
	subroutine putwrd(wrdbuf)
	character wrdbuf(INSIZE)
	integer length, width
	integer last, llval, nextra, w
	include cout
	include cparam

	w = width(wrdbuf)
	last = length(wrdbuf) + outp + 1	# new end of outbuf
	llval = rmval - tival
	if (outp > 0 & (outw+w > llval | last >= MAXOUT)) {   # too big
		last = last - outp		# remember end of wrdbuf
		nextra = llval - outw + 1
		call spread(outbuf, outp, nextra, outwds)
		if (nextra > 0 & outwds > 1)
			outp = outp + nextra
		call brk			# flush previous line
		}
	call scopy(wrdbuf, 1, outbuf, outp+1)
	outp = last
	outbuf(outp) = BLANK		# blank between words
	outw = outw + w + 1		# 1 for blank
	outwds = outwds + 1
	return
	end

roffdefs        362839385   9     1     100666  326       `
define	INSIZE	300
define	MAXOUT	300
define	COMMAND	PERIOD
define	PAGENUM	SHARP
define	PAGEWIDTH	60
define	PAGELEN	66

define UNKNOWN 0
define FI 1
define NF 2
define BR 3
define LS 4
define BP 5
define SP 6
define IN 7
define RM 8
define TI 9
define CE 10
define UL 11
define HE 12
define FO 13
define PL 14

define	HUGE	1000
set.r           362839397   9     1     100666  485       `
include globdefs
include roffdefs
# set _ set parameter and check range
	subroutine set(param, val, argtyp, defval, minval, maxval)
	integer max, min
	integer argtyp, defval, maxval, minval, param, val

	if (argtyp == NEWLINE)		# defaulted
		param = defval
	else if (argtyp == PLUS)		# relative +
		param = param + val
	else if (argtyp == MINUS)	# relative -
		param = param - val
	else					# absolute
		param = val
	param = min(param, maxval)
	param = max(param, minval)
	return
	end

skip.r          362839398   9     1     100666  193       `
include globdefs
include roffdefs
# skip _ output  n  blank lines
	subroutine skip(n)
	integer i, n

	for (i = 1; i <= n; i = i + 1) {
		call putc(PERIOD)
		call putc(NEWLINE)
		}
	return
	end

skipbl.r        362839381   9     1     100666  201       `
include /usr/style/io/globdefs
# skipbl _ skip blanks and tabs at lin(i)...
	subroutine skipbl(lin, i)
	character lin(ARB)
	integer i

	while (lin(i) == BLANK | lin(i) == TAB)
		i = i + 1
	return
	end

space.r         362839398   9     1     100666  319       `
include globdefs
include roffdefs
# space _ space  n  lines or to bottom of page
	subroutine space(n)
	integer min
	integer n
	include cpage

	call brk
	if (lineno > bottom)
		return
	if (lineno == 0)
		call phead
	call skip(min(n, bottom+1-lineno))
	lineno = lineno + n
	if (lineno > bottom)
		call pfoot
	return
	end

spread.r        362839394   9     1     100666  717       `
include globdefs
include roffdefs
# spread _ spread words to justify right margin
	subroutine spread(buf, outp, nextra, outwds)
	character buf(MAXOUT)
	integer min
	integer dir, i, j, nb, ne, nextra, nholes, outp, outwds
	data dir /0/

	if (nextra <= 0 | outwds <= 1)
		return
	dir = 1 - dir	# reverse previous direction
	ne = nextra
	nholes = outwds - 1
	i = outp - 1
	j = min(MAXOUT-2, i+ne)	# leave room for NEWLINE, EOS
	while (i < j) {
		buf(j) = buf(i)
		if (buf(i) == BLANK) {
			if (dir == 0)
				nb = (ne-1) / nholes + 1
			else
				nb = ne / nholes
			ne = ne - nb
			nholes = nholes - 1
			for ( ; nb > 0; nb = nb - 1) {
				j = j - 1
				buf(j) = BLANK
				}
			}
		i = i - 1
		j = j - 1
		}
	return
	end

sputwrd.r       362839413   9     1     100666  611       `
include globdefs
include roffdefs
# putwrd _ put a word in outbuf
	subroutine putwrd(wrdbuf)
	character wrdbuf(INSIZE)
	integer length, width
	integer last, llval, w
	include cout
	include cparam

	w = width(wrdbuf)
	last = length(wrdbuf) + outp + 1	# new end of outbuf
	llval = rmval - tival
	if (outp > 0 & (outw+w > llval | last >= MAXOUT)) {   # too big
		last = last - outp		# remember end of wrdbuf
		call brk			# flush previous line
		}
	call scopy(wrdbuf, 1, outbuf, outp+1)
	outp = last
	outbuf(outp) = BLANK		# blank between words
	outw = outw + w + 1		# 1 for blank
	outwds = outwds + 1
	return
	end

test            362839405   9     1     100666  5524      `
.he "Chapter 4, Page #
.fo #
.ls 2
.ce
.ul
SORTING
.PP
.sp
.ti +5
Sorting is an everyday programming task,
and often a building block in larger processes.
In this chapter we will tackle sorting, but
we will be more concerned with how a sort should appear to its users
than with presenting some ``best possible'' sorting algorithm.
If the sorting program is so poorly packaged
that users feel compelled to write their own
instead of figuring out how to use it,
then the quality of the algorithm it uses is irrelevant.
But if the packaging is good,
if users perceive sorting as an easy-to-use 
.ul
tool,
then it will be used, the algorithm can be improved as needed;
and
.ul
all
users will benefit.
.SH
.bp
.ce
.ul
Bubble Sort
.PP
.sp
.ti +5
Every programmer is familiar with some variant of the 
interchange sort.
For example the
.ul
bubble sort
sorts an array into ascending order like this:
.P1
.sp
.nf
.in +5
.ls 1
# bubble _ bubble sort v(1) ... v(n) increasing
	subroutine bubble(v, n)
	integer i, j, k, n, v(n)

	for (i = n; i > 1; i = i-1)
		for (j = 1; j < i; j = j + 1)
			if (v(j) > v(j+1)) {	# compare
				k = v(j)		# exchange
				v(j) = v(j+1)		#
				v(j+1) = k		#
				}
	return
	end
.P2
.sp
.fi
.in -5
.ls 2
The inner loop rearranges out-of-order adjacent elements
on each pass;
by the end of the pass, the largest element
has been ``bubbled'' to the top,
that is, to
.ul
v(i) .
The outer loop repeats the process, each time decreasing the current array limit 
.ul
i
by one.
.PP
.sp
.ti +5
The main advantage of the bubble sort is its simplicity.
Its drawback, a serious one,
is that it gets very slow very fast
as 
the number of elements to be sorted
gets large.
The 
.ul
time complexity 
of bubble sorting (and similar sorts) is
.IT n\s-1\u2\d\s+1 .
That is, the time required to sort varies
as the square of the number of items to be sorted:
twice as big takes about four times as long.
How large is too large?
That depends on the alternative being considered,
and on how often the data is to be sorted,
but something between
ten
and
fifty
items
might be a reasonable limit,
above which the bubble sort
is better replaced by a more sophisticated algorithm.
.PP
.sp
.ti +5
In real life, by the way,
you would certainly name the routine
.ul
sort ,
not
.ul
bubble ,
so you could change the algorithm without upsetting users.
We use
.ul
bubble
here because we want a unique name for each program.
.SH
.bp
.ce
.ul
Shell Sort
.PP
.sp
.ti +5
In a sense, the Shell sort is the next step up in complexity
from the bubble sort;
we present it because it is similar in spirit, compact,
but much faster for larger arrays.
The time complexity of the Shell sort is approximately
.IT n\s-1\u\fR1.5\fP\d\s+1 .
.PP
.sp
.ti +5
The basic idea of the Shell sort is that
in the early stages far-apart elements are compared,
instead of adjacent ones.
This tends to eliminate large amounts of disorder quickly,
so later stages have less work to do.
Gradually the interval between compared elements is decreased,
until it reaches one,
at which point it effectively
becomes
an adjacent interchange method.
.P1
.sp
.nf
.in +5
.ls 1
# shell _ Shell sort v(1)...v(n) increasing
	subroutine shell(v, n)
	integer gap, i, j, jg, k, n, v(n)

	for (gap = n/2; gap > 0; gap = gap/2)
		for (i = gap + 1; i <= n; i = i + 1)
			for (j = i - gap; j > 0; j = j - gap) {
				jg = j + gap
				if (v(j) <= v(jg))	# compare
					break
				k = v(j)		# exchange
				v(j) = v(jg)		#
				v(jg) = k		#
				}
	return
	end
.P2
.sp
.fi
.in -5
.ls 2
The outermost loop controls the gap between compared elements.
Initially
.ul
n/2 ,
it shrinks by a factor of two each pass until it becomes zero.
The middle loop compares elements separated by
.ul
gap ;
the innermost loop reverses any that are out of order.
Since
.ul
gap
is eventually reduced to one,
eventually all elements are ordered correctly.
.PP
.sp
.ti +5
A word on modularity.
Many sorting procedures
have three distinct parts.
A
.ul
comparison
operation
decides what the order of two elements is.
An
.ul
exchange
operation interchanges two out-of-order elements.
Finally, a
.ul
sorting algorithm
decides what comparisons and exchanges must be made.
Often the only thing that need change between
two sorting procedures is the algorithm,
so a program should be carefully organized to take this into account.
If the three functions are clearly separated,
each may be individually improved
without affecting the others.
.EX
In our version of the Shell sort,
when two out-of-order elements are found they are immediately exchanged.
If an element is small relative to the other elements
at the current gap, however,
several unnecessary exchanges may be performed.
Redistribute the exchange so
the element moving toward the beginning of the array is held in a temporary location
until its correct position has been found.
Measure this version to decide
if the increase in speed outweighs
the loss of clarity in the algorithm.
.XE
.EX
How would you test a sorting program?
What are the obvious boundary conditions that must be checked
to ensure correct operation?
What programs would you write to help in your verification?
What programs have we already written that help?
.XE
.EX
Compare the bubble sort and the Shell sort experimentally.
Where is the crossover point at which the Shell sort
becomes better on your machine?
.XE
.EX
The Shell sort
has been observed to
run somewhat faster when the value of
.ul
gap
is always odd.
Modify
.ul
shell
accordingly
and experiment to see how large the effect is.
.XE
text.r          362839413   9     1     100666  693       `
include globdefs
include roffdefs
# text _ process text lines (final version)
	subroutine text(inbuf)
	character inbuf(INSIZE), wrdbuf(INSIZE)
	integer getwrd
	integer i
	include cparam

	if (inbuf(1) == BLANK | inbuf(1) == NEWLINE)
		call leadbl(inbuf)	# move left, set tival
	if (ulval > 0) {		# underlining
		call underl(inbuf, wrdbuf, INSIZE)
		ulval = ulval - 1
		}
	if (ceval > 0) {		# centering
		call center(inbuf)
		call put(inbuf)
		ceval = ceval - 1
		}
	else if (inbuf(1) == NEWLINE)	# all blank line
		call put(inbuf)
	else if (fill == NO)		# unfilled text
		call put(inbuf)
	else				# filled text
		for (i = 1; getwrd(inbuf, i, wrdbuf) > 0; )
			call putwrd(wrdbuf)
	return
	end

text0.r         362839412   9     1     100666  162       `
include globdefs
include roffdefs
# text _ process text lines (interim version 1)
	subroutine text(inbuf)
	character inbuf(INSIZE)

	call put(inbuf)
	return
	end
text1.r         362839414   9     1     100666  504       `
include globdefs
include roffdefs
# text _ process text lines (interim version 2)
	subroutine text(inbuf)
	character inbuf(INSIZE), wrdbuf(INSIZE)
	integer getwrd
	integer i
	include cparam

	if (inbuf(1) == BLANK | inbuf(1) == NEWLINE)
		call leadbl(inbuf)	# move left, set tival
	if (inbuf(1) == NEWLINE)	# all blank line
		call put(inbuf)
	else if (fill == NO)		# unfilled text
		call put(inbuf)
	else				# filled text
		for (i = 1; getwrd(inbuf, i, wrdbuf) > 0; )
			call putwrd(wrdbuf)
	return
	end
underl.r        362839401   9     1     100666  501       `
include globdefs
include roffdefs
# underl _ underline a line
	subroutine underl(buf, tbuf, size)
	integer i, j, size
	character buf(size), tbuf(size)

	j = 1		# expand into tbuf
	for (i = 1; buf(i) != NEWLINE & j < size-1; i = i + 1) {
		tbuf(j) = buf(i)
		j = j + 1
		if (buf(i) != BLANK & buf(i) != TAB & buf(i) != BACKSPACE) {
			tbuf(j) = BACKSPACE
			tbuf(j+1) = UNDERLINE
			j = j + 2
			}
		}
	tbuf(j) = NEWLINE
	tbuf(j+1) = EOS
	call scopy(tbuf, 1, buf, 1)	# copy it back to buf
	return
	end

width.r         362839391   9     1     100666  305       `
include globdefs
include roffdefs
# width _ compute width of character string
	integer function width(buf)
	character buf(MAXLINE)
	integer i

	width = 0
	for (i = 1; buf(i) != EOS; i = i + 1)
		if (buf(i) == BACKSPACE)
			width = width - 1
		else if (buf(i) != NEWLINE)
			width = width + 1
	return
	end

