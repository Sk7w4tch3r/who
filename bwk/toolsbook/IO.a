!<arch>
cant.r          362839494   9     1     100666  139       `

include globdefs

#cant
	subroutine cant(buf)
	integer buf(MAXLINE)

	call putlin(buf, ERROUT)
	call error(" : can't open.")
	return
	end

create.r        362839493   9     1     100666  416       `
include iodefs

#create
# creates 666 mode, then opens for R/W
	integer function create(buf,mode)
	integer buf(MAXLINE), mode
	integer name4(15), creat, open, close, i, junk
	integer *1 name1(60)
		equivalence(name1(1),name4(1))

	for( i=1; buf(i)!=EOS; i=i+1 )
		name1(i) = buf(i)
	name1(i) = BLANK
	create = creat(name4,438)
	if( create < 0 )
		return
	junk = close(create)
	create = open(name4,mode)
	return
	end
ctoi.r          362839495   9     1     100666  660       `
include globdefs
# ctoi _ convert string at in(i) to integer, increment i
	integer function ctoi(in, i)
	character in(ARB)
	integer index
	integer d, i
#	string digits "0123456789"
	integer digits(11)
	data digits(1) /DIG0/
	data digits(2) /DIG1/
	data digits(3) /DIG2/
	data digits(4) /DIG3/
	data digits(5) /DIG4/
	data digits(6) /DIG5/
	data digits(7) /DIG6/
	data digits(8) /DIG7/
	data digits(9) /DIG8/
	data digits(10) /DIG9/
	data digits(11) /EOS/

	while (in(i) == BLANK | in(i) == TAB)
		i = i + 1
	for (ctoi = 0; in(i) != EOS; i = i + 1) {
		d = index(digits, in(i))
		if (d == 0)		# non\(hydigit
			break
		ctoi = 10 * ctoi + d - 1
		}
	return
	end
digits          362839500   9     1     100666  314       `
#	string digits "0123456789"
	integer digits(11)
		data digits(1) /DIG0/
		data digits(2) /DIG1/
		data digits(3) /DIG2/
		data digits(4) /DIG3/
		data digits(5) /DIG4/
		data digits(6) /DIG5/
		data digits(7) /DIG6/
		data digits(8) /DIG7/
		data digits(9) /DIG8/
		data digits(10) /DIG9/
		data digits(11) /EOS/
equal.r         362839522   9     1     100666  283       `
include globdefs
# equal _ compare str1 to str2; return YES if equal, NO if not
	integer function equal(str1, str2)
	character str1(ARB), str2(ARB)
	integer i

	for (i = 1; str1(i) == str2(i); i = i + 1)
		if (str1(i) == EOS) {
			equal = YES
			return
			}
	equal = NO
	return
	end

error.r         362839490   9     1     100666  100       `

include globdefs

#error
	subroutine error(buf)
	integer buf(MAXLINE)
	call remark(buf)
	stop
	end
fcopy.r         362839490   9     1     100666  209       `
include globdefs
# fcopy _ copy file  in  to file  out
	subroutine fcopy(in, out)
	character buf(MAXLINE)
	integer getlin
	integer in, out

	while (getlin(buf, in) != EOF)
		call putlin(buf, out)
	return
	end

getarg.r        362839489   9     1     100666  445       `

include iodefs

#getarg
# temporarily named gtarg to avoid conflict with system getarg
	integer function gtarg(n,buf,size)
	integer n, size, buf(size)
	integer iargc, min0, getarg
	integer wbuf(20), i, junk
	integer *1 cbuf(80)
		equivalence(wbuf(1),cbuf(1))

	if( n >= iargc(junk) ) {
		buf(1) = EOS
		gtarg = EOF
		return
	}
	gtarg = min0( getarg(n+1, wbuf), size-1)
	for( i=1; i<=gtarg; i=i+1 )
		buf(i) = cbuf(i)
	buf(i) = EOS
	return
	end

getc.r          362839485   9     1     100666  109       `

include globdefs

#getc
	integer function getc(ch)
	integer ch, getch

	getc = getch(ch,STDIN)
	return
	end

getch.r         362839485   9     1     100666  374       `

include globdefs

#getch
	integer function getch(ch,fd)
	integer ch,fd
	integer i, n, read
	integer *1 c
	if( fd < 0 ) {
		write(6,1) fd
		1 format('bad fd in getch:' i5)
		getch = EOS
		ch = EOS
		return
	}
	n = read(fd, c, 1)
	if (n == 0) {
		getch = EOF
		ch = EOF
		}
	else if (n == 1) {
		getch = c
		ch = c
		}
	else
		call error("read error in getch.")
	return
	end
getlin.r        362839473   9     1     100666  556       `
include iodefs
#getlin
	integer function getlin(buf,fd)
	integer buf(MAXLINE),fd
	integer i, n, read
	integer *1 c
	if (fd < 0) {
		write(6,1) fd
		1 format('bad fd in getlin:' i5)
		getlin = ERR
		buf(1) = EOS
		return
	}
	for( i=1; i<MAXLINE;i=i+1 ) {
		n = read(fd, c, 1)
		if (n == 0) {
			getlin = EOF
			buf(1) = EOS
			return
			}
		else if (n == 1)
			buf(i) = c
		else {
			call error("read error in getlin.")
			}
		if( buf(i) == NEWLINE ) {
			buf(i+1) = EOS
			getlin = i
			return
			}
		}
	call error("too long line in getlin.")
	return
	end
globdefs        362839474   9     1     100666  1868      `
define	STDIN	0
define	STDOUT	1
define	ERROUT	2
define	READ	0
define	WRITE	2
define	READWRITE	2

define	character	integer
define	LETTER	1
define	DIGIT	2
define	OTHER	3
define	YES	1
define	NO	0
define  OK	0
define	MAXLINE	100
define	ARB	100

define	EOF	-3
define	ERR	-1
define	EOS	-2

define	BACKSPACE	8
define	TAB	9
define	NEWLINE	10
define	BLANK	32	# octal 40
define	BANG	33
define	DQUOTE	34
define	SHARP	35
define	DOLLAR	36	# 44/8
define	PERCENT	37
define  AND 	38
define	SQUOTE	39
define	LPAREN	40
define	RPAREN	41
define	STAR	42
define	PLUS	43
define	COMMA	44
define	MINUS	45
define	PERIOD	46
define  SLASH	47
define	COLON	58
define	SEMICOL	59
define	LESS	60
define  EQUALS	61
define	GREATER	62
define  QMARK	63
define	ATSIGN	64
define	LBRACK	91
define	BACKSLASH	92
define	RBRACK	93
define	UNDERLINE	95
define	LBRACE	123
define	BAR	124
define	RBRACE	125

define	LETA	97
define	LETB	98
define	LETC	99
define	LETD	100
define	LETE	101
define	LETF	102
define	LETG	103
define	LETH	104
define	LETI	105
define	LETJ	106
define	LETK	107
define	LETL	108
define	LETM	109
define	LETN	110
define	LETO	111
define	LETP	112
define	LETQ	113
define	LETR	114
define	LETS	115
define	LETT	116
define	LETU	117
define	LETV	118
define	LETW	119
define	LETX	120
define	LETY	121
define	LETZ	122
define	BIGA	65
define	BIGB	66
define	BIGC	67
define	BIGD	68
define	BIGE	69
define	BIGF	70
define	BIGG	71
define	BIGH	72
define	BIGI	73
define	BIGJ	74
define	BIGK	75
define	BIGL	76
define	BIGM	77
define	BIGN	78
define	BIGO	79
define	BIGP	80
define	BIGQ	81
define	BIGR	82
define	BIGS	83
define	BIGT	84
define	BIGU	85
define	BIGV	86
define	BIGW	87
define	BIGX	88
define	BIGY	89
define	BIGZ	90
define	DIG0	48
define	DIG1	49
define	DIG2	50
define	DIG3	51
define	DIG4	52
define	DIG5	53
define	DIG6	54
define	DIG7	55
define	DIG8	56
define	DIG9	57

define	open	fopen
define	getarg	gtarg
define	seek	fseek
index.r         362839496   9     1     100666  243       `
include /usr/style/io/globdefs
# index : find character  c  in string  str
	integer function index(str, c)
	character c, str(ARB)

	for (index = 1; str(index) != EOS; index = index + 1)
		if (str(index) == c)
			return
	index = 0
	return
	end

iodefs          362839475   9     1     100666  938       `
define	STDIN	0
define	STDOUT	1
define	ERROUT	2
define	READ	0
define	READWRITE	2

define	LETTER	1
define	DIGIT	2
define	OTHER	3
define	YES	1
define	NO	0
define	MAXLINE	100
define	ARB	100

define	EOF	-3
define	ERR	-1
define	EOS	-2
define	NEWLINE	10
define	BLANK	32	# octal 40
define	BANG	33
define	DOLLAR	36	# 44/8
define	STAR	42
define	COMMA	44
define	MINUS	45
define	PERIOD	46
define	ATSIGN	64

define	LETA	97
define	LETB	98
define	LETC	99
define	LETD	100
define	LETE	101
define	LETF	102
define	LETG	103
define	LETH	104
define	LETI	105
define	LETJ	106
define	LETK	107
define	LETL	108
define	LETM	109
define	LETN	110
define	LETO	111
define	LETP	112
define	LETQ	113
define	LETR	114
define	LETS	115
define	LETT	116
define	LETU	117
define	LETV	118
define	LETW	119
define	LETX	120
define	LETY	121
define	LETZ	122
define	BIGA	65
define	BIGE	69
define	BIGH	72
define	BIGZ	90
define	DIG0	48
define	DIG9	57


define	seek	fseek

define	BUFSIZE	512
itoc.r          362839473   9     1     100666  904       `

include globdefs
define abs iabs
# itoc _ convert integer  int  to char string in  str
	integer function itoc(int, str, size)
	integer abs, mod
	integer d, i, int, intval, j, k, size
	character str(size)
#	string digits "0123456789"
	integer digits(11)
	data digits(1) /DIG0/
	data digits(2) /DIG1/
	data digits(3) /DIG2/
	data digits(4) /DIG3/
	data digits(5) /DIG4/
	data digits(6) /DIG5/
	data digits(7) /DIG6/
	data digits(8) /DIG7/
	data digits(9) /DIG8/
	data digits(10) /DIG9/
	data digits(11) /EOS/

	intval = abs(int)
	str(1) = EOS
	i = 1
	repeat {				# generate digits
		i = i + 1
		d = mod(intval, 10)
		str(i) = digits(d+1)
		intval = intval / 10
		} until (intval == 0 | i >= size)
	if (int < 0 & i < size) {		# then sign
		i = i + 1
		str(i) = MINUS
		}
	itoc = i - 1
	for (j = 1; j < i; j = j + 1) {	# then reverse
		k = str(i)
		str(i) = str(j)
		str(j) = k
		i = i - 1
		}
	return
	end
length.r        362839495   9     1     100666  196       `

include /usr/style/io/globdefs

# length : compute length of string
	integer function length(str)
	integer str(ARB)

	for (length = 0; str(length+1) != EOS; length = length + 1)
		;
	return
	end
lowalf          362839500   9     1     100666  685       `
#	string lowalf "abcdefghijklmnopqrstuvwxyz"
	integer lowalf(27)
	data lowalf(01)/LETA/
	data lowalf(02)/LETB/
	data lowalf(03)/LETC/
	data lowalf(04)/LETD/
	data lowalf(05)/LETE/
	data lowalf(06)/LETF/
	data lowalf(07)/LETG/
	data lowalf(08)/LETH/
	data lowalf(09)/LETI/
	data lowalf(10)/LETJ/
	data lowalf(11)/LETK/
	data lowalf(12)/LETL/
	data lowalf(13)/LETM/
	data lowalf(14)/LETN/
	data lowalf(15)/LETO/
	data lowalf(16)/LETP/
	data lowalf(17)/LETQ/
	data lowalf(18)/LETR/
	data lowalf(19)/LETS/
	data lowalf(20)/LETT/
	data lowalf(21)/LETU/
	data lowalf(22)/LETV/
	data lowalf(23)/LETW/
	data lowalf(24)/LETX/
	data lowalf(25)/LETY/
	data lowalf(26)/LETZ/
	data lowalf(27)/EOS/

max.r           362839522   9     1     100666  99        `
#max
	integer function max(i, j)
	integer i, j

	if (i > j)
		max = i
	else
		max = j
	return
	end

min.r           362839505   9     1     100666  99        `
#min
	integer function min(i, j)
	integer i, j

	if (i < j)
		min = i
	else
		min = j
	return
	end

open.r          362839492   9     1     100666  393       `
include iodefs

#open
# called fopen to avoid conflict with system open
	integer function fopen(buf,mode)
	integer buf(MAXLINE), mode
	integer name4(15), open, i
	integer *1 name1(60)
		equivalence(name1(1),name4(1))

	for( i=1; buf(i)!=EOS; i=i+1 )
		name1(i) = buf(i)
	if(i <= 1) {
		fopen = -1
		return
		}
	name1(i) = BLANK
	fopen = open(name4,mode)
	if( fopen < 0 )
		return
	return
	end

putc.r          362839489   9     1     100666  110       `

include globdefs

#putc
	integer function putc(ch)
	integer ch, putch

	putc = putch(ch,STDOUT)
	return
	end
putch.r         362839487   9     1     100666  169       `

include globdefs

#putch
	integer function putch(inchar, fd)
	integer inchar, fd, write, nb
	integer *1 c

	c = inchar
	nb = write(fd,c,1)
	putch = inchar
	return
	end

putdec.r        362839496   9     1     100666  336       `

include globdefs
define	MAXCHARS	10

# putdec _ put decimal integer  n  in field width >= w
	subroutine putdec(n, w)
	character chars(MAXCHARS)
	integer itoc
	integer i, n, nd, w

	nd = itoc(n, chars, MAXCHARS)
	for (i = nd + 1; i <= w; i = i + 1)
		call putc(BLANK)
	for (i = 1; i <= nd; i = i + 1)
		call putc(chars(i))
	return
	end
putlin.r        362839486   9     1     100666  346       `

include iodefs

#putlin
	integer function putlin(buf,fd)
	integer buf(MAXLINE), fd, write, i, nb
	integer *1 cbuf(BUFSIZE)

	for( i=1; i<=BUFSIZE & buf(i)!=EOS; i=i+1 )
		cbuf(i) = buf(i)
	if( i > BUFSIZE )
		call error("too long line in putlin.")
	nb = write(fd,cbuf,i-1)
	if( nb != i-1 )
		call error("write error.")
	putlin = nb
	return
	end
readf.r         362839497   9     1     100666  451       `

include globdefs

#readf
	integer function readf(buf, nc, fd)
	# reads nc chars, unpacked into buf from fd
	# returns # chars read or EOF
	# terminates buf(nread+1) with EOS
	integer buf(nc), nc, fd, read, i
	integer *1 cbuf(512)

	if (nc <= 0) {
		readf = 0
		buf(1) = EOS
		return
		}
	readf = read(fd, cbuf, nc)
	if (readf <= 0) {
		readf = EOF
		buf(1) = EOS
		return
		}
	for (i=1; i<=readf; i=i+1)
		buf(i) = cbuf(i)
	buf(i) = EOS
	return
	end

remark.r        362839493   9     1     100666  326       `

include globdefs

#remark
	subroutine remark(buf)
	integer buf(MAXLINE), i, j, b
	integer *1 c(4)
		equivalence(c,b)

	i = 0
	j = 0
	repeat {
		j = j + 1
		if( j > 4 )
			j = 1
		if( j == 1 ) {
			i = i + 1
			b = buf(i)
			}
		call write(2,c(j),1)
	} until (c(j) ==PERIOD)
	c(1) = NEWLINE
	call write(2,c(1),1)
	return
	end
remove.r        362839493   9     1     100666  259       `

include globdefs

#remove
	integer function remove(buf)
	integer buf(MAXLINE)
	integer *1 cbuf(80)
	integer bbuf(20), unlink, i
		equivalence(cbuf,bbuf)

	for( i=1; buf(i)!=EOS; i=i+1 )
		cbuf(i) = buf(i)
	cbuf(i) = BLANK
	remove = unlink(bbuf)
	return
	end

scopy.r         362839499   9     1     100666  279       `
include /usr/style/io/globdefs
# scopy _ copy string at from(i) to to(j)
	subroutine scopy(from, i, to, j)
	character from(ARB), to(ARB)
	integer i, j, k1, k2

	k2 = j
	for (k1 = i; from(k1) != EOS; k1 = k1 + 1) {
		to(k2) = from(k1)
		k2 = k2 + 1
		}
	to(k2) = EOS
	return
	end

seek.r          362839494   9     1     100666  127       `

include globdefs

#seek
	integer function seek(byte,fd)
	integer byte,fd

	integer seek0

	seek = seek0(fd,byte)
	return
	end

type.r          362839489   9     1     100666  274       `

include globdefs

#type
# this one works with ascii alphabet
	integer function type(c)
	integer c

	if( c >= DIG0 & c <= DIG9 )
		type = DIGIT
	else if( c >= LETA & c <= LETZ )
		type = LETTER
	else if( c >= BIGA & c <= BIGZ )
		type = LETTER
	else
		type = c
	return
	end
upalf           362839501   9     1     100666  683       `
#	string upalf "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
	integer upalf(27)
	data upalf(01) /BIGA/
	data upalf(02) /BIGB/
	data upalf(03) /BIGC/
	data upalf(04) /BIGD/
	data upalf(05) /BIGE/
	data upalf(06) /BIGF/
	data upalf(07) /BIGG/
	data upalf(08) /BIGH/
	data upalf(09) /BIGI/
	data upalf(10) /BIGJ/
	data upalf(11) /BIGK/
	data upalf(12) /BIGL/
	data upalf(13) /BIGM/
	data upalf(14) /BIGN/
	data upalf(15) /BIGO/
	data upalf(16) /BIGP/
	data upalf(17) /BIGQ/
	data upalf(18) /BIGR/
	data upalf(19) /BIGS/
	data upalf(20) /BIGT/
	data upalf(21) /BIGU/
	data upalf(22) /BIGV/
	data upalf(23) /BIGW/
	data upalf(24) /BIGX/
	data upalf(25) /BIGY/
	data upalf(26) /BIGZ/
	data upalf(27) /EOS/

