!<arch>
blockd.r        362839794   9     1     100666  100       `
include /usr/style/io/globdefs
# block data for macro
	block data
	include cdefio
	data bp /0/
	end
cdefio          362839774   9     1     100666  149       `
define BUFSIZE 500
common /cdefio/ bp, buf(BUFSIZE)
   integer bp		# next available character; init = 0
   character buf	# pushed\(hyback characters

clook           362839772   9     1     100666  246       `
common /clook/ lastp, lastt, namptr(MAXPTR), table(MAXTBL)
   integer lastp		# last used in namptr; init = 0
   integer lastt		# last used in table; init = 0
   integer namptr		# name pointers
   character table		# actual text of names and defns
cmacro          362839794   9     1     100666  173       `
common /cmacro/ cp, ep, evalst(EVALSIZE)
   integer cp			# current call stack pointer
   integer ep			# next free position in evalst
   character evalst		# evaluation stack

defdefs         362839761   9     1     100666  292       `
define	ALPHA	-100
define	MAXTBL	500
define	MAXPTR	50
define	CALLSIZE	20
define	ARGSIZE	100
define	MAXDEF	200	# max chars in a defn
define	MAXTOK	200	# max chars in a token

define	ARGFLAG	DOLLAR

define	DEFTYPE	-10
define	IFTYPE	-11
define	INCTYPE	-12
define	SUBTYPE	-13

define	EVALSIZE	500
gettok.r        362839807   9     1     100666  559       `
include /usr/style/io/globdefs
include defdefs
# gettok _ get alphanumeric string or single non\(hyalpha for define
	character function gettok(token, toksiz)
	character ngetc, type
	integer i, toksiz
	character token(toksiz)

	for (i = 1; i < toksiz; i = i + 1) {
		gettok = type(ngetc(token(i)))
		if (gettok != LETTER & gettok != DIGIT)
			break
		}
	if (i >= toksiz)
		call error("token too long.")
	if (i > 1) {			# some alpha was seen
		call putbak(token(i))
		i = i - 1
		gettok = ALPHA
		}
	# else single character token
	token(i+1) = EOS
	return
	end

globdefs        362839788   9     1     100666  1868      `
define	STDIN	0
define	STDOUT	1
define	ERROUT	2
define	READ	0
define	WRITE	2
define	READWRITE	2

define	character	integer
define	LETTER	1
define	DIGIT	2
define	OTHER	3
define	YES	1
define	NO	0
define  OK	0
define	MAXLINE	100
define	ARB	100

define	EOF	-3
define	ERR	-1
define	EOS	-2

define	BACKSPACE	8
define	TAB	9
define	NEWLINE	10
define	BLANK	32	# octal 40
define	BANG	33
define	DQUOTE	34
define	SHARP	35
define	DOLLAR	36	# 44/8
define	PERCENT	37
define  AND 	38
define	SQUOTE	39
define	LPAREN	40
define	RPAREN	41
define	STAR	42
define	PLUS	43
define	COMMA	44
define	MINUS	45
define	PERIOD	46
define  SLASH	47
define	COLON	58
define	SEMICOL	59
define	LESS	60
define  EQUALS	61
define	GREATER	62
define  QMARK	63
define	ATSIGN	64
define	LBRACK	91
define	BACKSLASH	92
define	RBRACK	93
define	UNDERLINE	95
define	LBRACE	123
define	BAR	124
define	RBRACE	125

define	LETA	97
define	LETB	98
define	LETC	99
define	LETD	100
define	LETE	101
define	LETF	102
define	LETG	103
define	LETH	104
define	LETI	105
define	LETJ	106
define	LETK	107
define	LETL	108
define	LETM	109
define	LETN	110
define	LETO	111
define	LETP	112
define	LETQ	113
define	LETR	114
define	LETS	115
define	LETT	116
define	LETU	117
define	LETV	118
define	LETW	119
define	LETX	120
define	LETY	121
define	LETZ	122
define	BIGA	65
define	BIGB	66
define	BIGC	67
define	BIGD	68
define	BIGE	69
define	BIGF	70
define	BIGG	71
define	BIGH	72
define	BIGI	73
define	BIGJ	74
define	BIGK	75
define	BIGL	76
define	BIGM	77
define	BIGN	78
define	BIGO	79
define	BIGP	80
define	BIGQ	81
define	BIGR	82
define	BIGS	83
define	BIGT	84
define	BIGU	85
define	BIGV	86
define	BIGW	87
define	BIGX	88
define	BIGY	89
define	BIGZ	90
define	DIG0	48
define	DIG1	49
define	DIG2	50
define	DIG3	51
define	DIG4	52
define	DIG5	53
define	DIG6	54
define	DIG7	55
define	DIG8	56
define	DIG9	57

define	open	fopen
define	getarg	gtarg
define	seek	fseek
look.r          362839757   9     1     100666  1076      `
include globdefs
include /usr/style/newdef/defdefs
# lookup _ locate name, extract definition from table
	integer function lookup(name, defn)
	character defn(MAXDEF), name(MAXTOK)
	integer i, j, k
	include clook
	
	for (i = lastp; i > 0; i = i - 1) {
		j = namptr(i)
		for (k = 1; name(k) == table(j) & name(k) != EOS; k = k + 1)
			j = j + 1
		if (name(k) == table(j)) {		# got one
			call scopy(table, j+1, defn, 1)
			lookup = YES
			return
			}
		}
	lookup = NO
	return
	end

# instal _ add name and definition to table
	subroutine instal(name, defn)
	character defn(MAXTOK), name(MAXDEF)
	integer length
	integer dlen, nlen
	include clook

	nlen = length(name) + 1
	dlen = length(defn) + 1
	if (lastt + nlen + dlen > MAXTBL | lastp >= MAXPTR) {
		call putlin(name, ERROUT)
		call remark(": too many definitions.")
		}
	lastp = lastp + 1
	namptr(lastp) = lastt + 1
	call scopy(name, 1, table, lastt + 1)
	call scopy(defn, 1, table, lastt + nlen + 1)
	lastt = lastt + nlen + dlen
	return
	end


#block data
	block data
	include clook

	data lastp /0/
	data lastt /0/

	end
mac.r           362839755   9     1     100666  6800      `
include /usr/style/io/globdefs
include	defdefs
# macro _ expand macros with arguments
	character gettok
	character defn(MAXDEF), t, token(MAXTOK)
	integer lookup, push
	integer ap, argstk(ARGSIZE), callst(CALLSIZE), nlb, plev(CALLSIZE)
	include cmacro
#	string balp "()"
	integer balp(3)
	data balp(1) /LPAREN/, balp(2) /RPAREN/, balp(3) /EOS/
#	string defnam "define"
	integer defnam(7)
	data defnam(1) /LETD/, defnam(2) /LETE/, defnam(3) /LETF/
	data defnam(4) /LETI/, defnam(5) /LETN/, defnam(6) /LETE/
	data defnam(7) /EOS/
#	string incnam "incr"
	integer incnam(5)
	data incnam(1) /LETI/, incnam(2) /LETN/, incnam(3) /LETC/, incnam(4) /LETR/
	data incnam(5) /EOS/
#	string subnam "substr"
	integer subnam(7)
	data subnam(1) /LETS/, subnam(2) /LETU/, subnam(3) /LETB/
	data subnam(4) /LETS/, subnam(5) /LETT/, subnam(6) /LETR/
	data subnam(7) /EOS/
#	string ifnam "ifelse"
	integer ifnam(7)
	data ifnam(1) /LETI/, ifnam(2) /LETF/, ifnam(3) /LETE/
	data ifnam(4) /LETL/, ifnam(5) /LETS/, ifnam(6) /LETE/
	data ifnam(7) /EOS/
	integer deftyp(2)
	data deftyp(1) /DEFTYPE/, deftyp(2) /EOS/
	integer inctyp(2)
	data inctyp(1) /INCTYPE/, inctyp(2) /EOS/
	integer subtyp(2)
	data subtyp(1) /SUBTYPE/, subtyp(2) /EOS/
	integer iftyp(2)
	data iftyp(1) /IFTYPE/, iftyp(2) /EOS/

	call instal(defnam, deftyp)
	call instal(incnam, inctyp)
	call instal(subnam, subtyp)
	call instal(ifnam, iftyp)

	cp = 0
	ap = 1
	ep = 1
	for (t = gettok(token, MAXTOK); t != EOF; t = gettok(token, MAXTOK)) {
		if (t == ALPHA) {
			if (lookup(token, defn) == NO)
				call puttok(token)
			else {				# defined; put it in eval stack
				cp = cp + 1
				if (cp > CALLSIZE)
					call error("call stack overflow.")
				callst(cp) = ap
				ap = push(ep, argstk, ap)
				call puttok(defn)	# stack definition
				call putchr(EOS)
				ap = push(ep, argstk, ap)
				call puttok(token)	# stack name
				call putchr(EOS)
				ap = push(ep, argstk, ap)
				t = gettok(token, MAXTOK)	# peek at next
				call pbstr(token)
				if (t != LPAREN)	# add ( ) if not present
					call pbstr(balp)
				plev(cp) = 0
				}
			}
		else if (t == LBRACK) {		# strip one level of [ ]
			nlb = 1
			repeat {
				t = gettok(token, MAXTOK)
				if (t == LBRACK)
					nlb = nlb + 1
				else if (t == RBRACK) {
					nlb = nlb - 1
					if (nlb == 0)
						break
					}
				else if (t == EOF)
					call error("EOF in string.")
				call puttok(token)
				}
			}
		else if (cp == 0)			# not in a macro at all
			call puttok(token)
		else if (t == LPAREN) {
			if (plev(cp) > 0)
				call puttok(token)
			plev(cp) = plev(cp) + 1
			}
		else if (t == RPAREN) {
			plev(cp) = plev(cp) - 1
			if (plev(cp) > 0)
				call puttok(token)
			else {				# end of argument list
				call putchr(EOS)
				call eval(argstk, callst(cp), ap-1)
				ap = callst(cp)	# pop eval stack
				ep = argstk(ap)
				cp = cp - 1
				}
			}
		else if (t == COMMA & plev(cp) == 1) {	# new arg
			call putchr(EOS)
			ap = push(ep, argstk, ap)
			}
		else
			call puttok(token)		# just stack it
		}
	if (cp != 0)
		call error("unexpected EOF.")
	stop
	end

# push _ push ep onto argstk, return new pointer ap
	integer function push(ep, argstk, ap)
	integer ap, argstk(ARGSIZE), ep

	if (ap > ARGSIZE)
		call error("arg stack overflow.")
	argstk(ap) = ep
	push = ap + 1
	return
	end

# puttok _ put a token either on output or into evaluation stack
	subroutine puttok(str)
	character str(MAXTOK)
	integer i

	for (i = 1; str(i) != EOS; i = i + 1)
		call putchr(str(i))
	return
	end

# putchr _ put single char on output or into evaluation stack
	subroutine putchr(c)
	character c
	include cmacro

	if (cp == 0)
		call putc(c)
	else {
		if (ep > EVALSIZE)
			call error("evaluation stack overflow.")
		evalst(ep) = c
		ep = ep + 1
		}
	return
	end

# eval _ expand args i through j: evaluate builtin or push back defn
	subroutine eval(argstk, i, j)
	integer index, length
	integer argno, argstk(ARGSIZE), i, j, k, m, n, t, td
	include cmacro
#	string digits "0123456789"
	integer digits(11)
	data digits(1) /DIG0/
	data digits(2) /DIG1/
	data digits(3) /DIG2/
	data digits(4) /DIG3/
	data digits(5) /DIG4/
	data digits(6) /DIG5/
	data digits(7) /DIG6/
	data digits(8) /DIG7/
	data digits(9) /DIG8/
	data digits(10) /DIG9/
	data digits(11) /EOS/

	t = argstk(i)
	td = evalst(t)
	if (td == DEFTYPE)
		call dodef(argstk, i, j)
	else if (td == INCTYPE)
		call doincr(argstk, i, j)
	else if (td == SUBTYPE)
		call dosub(argstk, i, j)
	else if (td == IFTYPE)
		call doif(argstk, i, j)
	else {
		for (k = t+length(evalst(t))-1; k > t; k = k - 1)
			if (evalst(k-1) != ARGFLAG)
				call putbak(evalst(k))
			else {
				argno = index(digits, evalst(k)) - 1
				if (argno >= 0 & argno < j-i) {
					n = i + argno + 1
					m = argstk(n)
					call pbstr(evalst(m))
					}
				k = k - 1	# skip over $
				}
		if (k == t)			# do last character
			call putbak(evalst(k))
		}
	return
	end

# dodef _ install definition in table
	subroutine dodef(argstk, i, j)
	integer a2, a3, argstk(ARGSIZE), i, j
	include cmacro

	if (j - i > 2) {
		a2 = argstk(i+2)
		a3 = argstk(i+3)
		call instal(evalst(a2), evalst(a3))	# subarrays
		}
	return
	end

# doincr _ increment argument by 1
	subroutine doincr(argstk, i, j)
	integer ctoi
	integer argstk(ARGSIZE), i, j, k
	include cmacro

	k = argstk(i+2)
	call pbnum(ctoi(evalst, k)+1)
	return
	end

# pbnum _ convert number to string, push back on input
	subroutine pbnum(n)
	integer mod
	integer m, n, num
#	string digits "0123456789"
	integer digits(11)
	data digits(1) /DIG0/
	data digits(2) /DIG1/
	data digits(3) /DIG2/
	data digits(4) /DIG3/
	data digits(5) /DIG4/
	data digits(6) /DIG5/
	data digits(7) /DIG6/
	data digits(8) /DIG7/
	data digits(9) /DIG8/
	data digits(10) /DIG9/
	data digits(11) /EOS/

	num = n
	repeat {
		m = mod(num, 10)
		call putbak(digits(m+1))
		num = num / 10
		} until (num == 0)
	return
	end

# dosub _ select substring
	subroutine dosub(argstk, i, j)
	integer ctoi, length, max, min
	integer ap, argstk(ARGSIZE), fc, i, j, k, nc
	include cmacro

	if (j - i < 3)
		return
	if (j - i < 4)
		nc = MAXTOK
	else {
		k = argstk(i+4)
		nc = ctoi(evalst, k)		# number of characters
		}
	k = argstk(i+3)			# origin
	ap = argstk(i+2)			# target string
	fc = ap + ctoi(evalst, k) - 1	# first char of substring
	if (fc >= ap & fc < ap + length(evalst(ap))) {	# subarrays
		k = fc + min(nc, length(evalst(fc))) - 1
		for ( ; k >= fc; k = k - 1)
			call putbak(evalst(k))
		}
	return
	end

# doif _ select one of two arguments
	subroutine doif(argstk, i, j)
	integer equal
	integer a2, a3, a4, a5, argstk(ARGSIZE), i, j
	include cmacro

	if (j - i < 5)
		return
	a2 = argstk(i+2)
	a3 = argstk(i+3)
	a4 = argstk(i+4)
	a5 = argstk(i+5)
	if (equal(evalst(a2), evalst(a3)) == YES)	# subarrays
		call pbstr(evalst(a4))
	else
		call pbstr(evalst(a5))
	return
	end
ngetc.r         362839760   9     1     100666  276       `
include /usr/style/io/globdefs
# ngetc _ get a (possibly pushed back) character
	character function ngetc(c)
	character getc
	character c
	include cdefio

	if (bp > 0)
		c = buf(bp)
	else {
		bp = 1
		buf(bp) = getc(c)
		}
	if (c != EOF)
		bp = bp - 1
	ngetc = c
	return
	end
pbstr.r         362839763   9     1     100666  202       `
include globdefs
# pbstr _ push string back onto input
	subroutine pbstr(in)
	character in(MAXLINE)
	integer length
	integer i

	for (i = length(in); i > 0; i = i - 1)
		call putbak(in(i))
	return
	end
putbak.r        362839760   9     1     100666  219       `
include globdefs

# putbak _ push character back onto input
	subroutine putbak(c)
	character c
	include cdefio

	bp = bp + 1
	if (bp > BUFSIZE)
		call error("too many characters pushed back.")
	buf(bp) = c
	return
	end

test.len        362839774   9     1     100666  84        `
define(len,[ifelse($1,,0,[incr(len(substr($1,2)))])])
len(abc)
len(ab)
len(a)
len()
test.ret        362839792   9     1     100666  133       `
define(return,[ifelse($1,,[[return]],{pname=$1;[[return]]})])
define(proc,fun $1($2)[define(pname,$1)])
proc(zip)
return
return(abc)

test.str        362839790   9     1     100666  299       `
define(len,[ifelse($1,,0,[incr(len(substr($1,2)))])])
define(string,[integer $1(len(substr($2,2)))
str($1,substr($2,2),0)
data $1(len(substr($2,2)))/EOS/
])
define(str,[ifelse($2,",,data $1(incr($3))/[LET]substr($2,1,1)/
[str($1,substr($2,2),incr($3))])])
string(xxx,"abc")
string(yyyy,"123456789")

triv.r          362839795   9     1     100666  1660      `
include /usr/style/io/globdefs
include	defdefs
# define _ simple string replacement macro processor
	character gettok
	character defn(MAXDEF), t, token(MAXTOK)
	integer lookup
#	string defnam "define"
	integer defnam(7)
	data defnam(1) /LETD/, defnam(2) /LETE/, defnam(3) /LETF/
	data defnam(4) /LETI/, defnam(5) /LETN/, defnam(6) /LETE/
	data defnam(7) /EOS/
	integer deftyp(2)
	data deftyp(1) /DEFTYPE/, deftyp(2) /EOS/

	call instal(defnam, deftyp)
	for (t = gettok(token, MAXTOK); t != EOF; t = gettok(token, MAXTOK))
		if (t != ALPHA)		# output non\(hyalpha tokens
			call putlin(token, STDOUT)
		else if (lookup(token, defn) == NO)	# and undefined
			call putlin(token, STDOUT)
		else if (defn(1) == DEFTYPE) {		# get definition
			call getdef(token, MAXTOK, defn, MAXDEF)
			call instal(token, defn)
			}
		else
			call pbstr(defn)	# push replacement onto input
	stop
	end

# getdef (for no arguments) _ get name and definition
	subroutine getdef(token, toksiz, defn, defsiz)
	character gettok, ngetc
	integer defsiz, i, nlpar, toksiz
	character c, defn(defsiz), token(toksiz)

	if (ngetc(c) != LPAREN)
		call error("missing left paren.")
	else if (gettok(token, toksiz) != ALPHA)
		call error("non-alphanumeric name.")
	else if (ngetc(c) != COMMA)
		call error("missing comma in define.")
	# else got (name,
	nlpar = 0
	for (i = 1; nlpar >= 0; i = i + 1)
		if (i > defsiz)
			call error("definition too long.")
		else if (ngetc(defn(i)) == EOF)
			call error("missing right paren.")
		else if (defn(i) == LPAREN)
			nlpar = nlpar + 1
		else if (defn(i) == RPAREN)
			nlpar = nlpar - 1
		# else normal character in defn(i)
	defn(i-1) = EOS
	return
	end
